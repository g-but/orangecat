a75da556e4e03e900414949eed2f9cac
/**
 * File Upload API Security Vulnerability Analysis
 *
 * Critical Attack Vector Assessment for Avatar & Banner Upload APIs
 * Testing malicious file upload prevention, resource exhaustion, and authorization bypass
 */
describe('🎯 File Upload API Security Assessment - Critical Attack Vector', () => {
    describe('🚨 CRITICAL: Malicious File Upload Prevention', () => {
        test('documents file type bypass vulnerabilities', () => {
            // Current file type validation from the API
            const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'];
            // Test legitimate files (should pass)
            const legitimateFiles = [
                { name: 'avatar.jpg', type: 'image/jpeg', size: 1024 },
                { name: 'banner.png', type: 'image/png', size: 2048 },
                { name: 'profile.webp', type: 'image/webp', size: 1536 }
            ];
            // Test malicious file type bypasses
            const maliciousFileTypes = [
                { name: 'shell.php', type: 'image/jpeg', description: 'PHP shell disguised as JPEG' },
                { name: 'malware.exe', type: 'image/png', description: 'Executable disguised as PNG' },
                { name: 'exploit.jsp', type: 'image/webp', description: 'JSP shell disguised as WebP' },
                { name: 'backdoor.aspx', type: 'image/gif', description: 'ASPX shell disguised as GIF' },
                { name: 'script.js', type: 'image/jpeg', description: 'JavaScript disguised as JPEG' },
                { name: 'polyglot.jpg', type: 'image/jpeg', description: 'Polyglot file (valid image + executable)' }
            ];
            // Test MIME type spoofing attacks
            const mimeTypeSpoofing = [
                { name: 'exploit.php', type: 'image/gif\x00.php', description: 'Null byte injection' },
                { name: 'shell.php', type: 'image/jpeg; charset=utf-8', description: 'MIME type with charset' },
                { name: 'malware.exe', type: 'image/png\r\nContent-Type: application/x-msdownload', description: 'Header injection' }
            ];
            // Security Impact Assessment
            const uploadSecurityRisks = [
                'Malicious files executed on server leading to full compromise',
                'Stored XSS through malicious SVG or image metadata',
                'Path traversal attacks to overwrite system files',
                'Resource exhaustion through ZIP bombs or large files',
                'Client-side malware distribution through platform',
                'Platform reputation destroyed by hosting malicious content'
            ];
            console.warn('🚨 FILE UPLOAD SECURITY RISKS:');
            uploadSecurityRisks.forEach(risk => console.warn(`  - ${risk}`));
            console.warn('🎯 MALICIOUS FILE TYPE BYPASSES:');
            maliciousFileTypes.forEach(({ name, type, description }) => {
                const wouldPass = allowedTypes.includes(type);
                console.warn(`  - ${name} (${type}): ${description} - ${wouldPass ? '⚠️ WOULD BYPASS' : '✅ BLOCKED'}`);
            });
            console.warn('📡 MIME TYPE SPOOFING ATTACKS:');
            mimeTypeSpoofing.forEach(({ name, type, description }) => {
                console.warn(`  - ${name}: ${description}`);
            });
            expect(uploadSecurityRisks).toHaveLength(6);
            expect(maliciousFileTypes).toHaveLength(6);
        });
        test('provides enhanced file validation security fix', () => {
            const enhancedFileValidation = `
        // ✅ ENHANCED FILE UPLOAD SECURITY
        async function validateUploadedFile(file: File, buffer: Buffer) {
          // 1. File extension validation (not just MIME type)
          const allowedExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif'];
          const fileExtension = path.extname(file.name).toLowerCase();
          if (!allowedExtensions.includes(fileExtension)) {
            return { valid: false, error: 'Invalid file extension' };
          }
          
          // 2. MIME type validation with strict checking
          const trustedMimeTypes = {
            '.jpg': ['image/jpeg'],
            '.jpeg': ['image/jpeg'],
            '.png': ['image/png'],
            '.webp': ['image/webp'],
            '.gif': ['image/gif']
          };
          
          if (!trustedMimeTypes[fileExtension]?.includes(file.type)) {
            return { valid: false, error: 'MIME type does not match file extension' };
          }
          
          // 3. Magic byte validation (file signature)
          const magicBytes = {
            'image/jpeg': [0xFF, 0xD8, 0xFF],
            'image/png': [0x89, 0x50, 0x4E, 0x47],
            'image/gif': [0x47, 0x49, 0x46],
            'image/webp': [0x52, 0x49, 0x46, 0x46] // RIFF header
          };
          
          const signature = magicBytes[file.type];
          if (signature) {
            const fileHeader = Array.from(buffer.slice(0, signature.length));
            const signatureMatch = signature.every((byte, index) => fileHeader[index] === byte);
            if (!signatureMatch) {
              return { valid: false, error: 'File signature does not match declared type' };
            }
          }
          
          // 4. Content scanning for embedded threats
          const suspiciousPatterns = [
            /<\\?php/gi,           // PHP code
            /<script/gi,          // JavaScript
            /<%/gi,               // JSP/ASP code
            /\\.exe\\b/gi,         // Executable references
            /\\.dll\\b/gi,         // DLL references
            /javascript:/gi,      // JavaScript protocol
            /vbscript:/gi         // VBScript protocol
          ];
          
          const fileContent = buffer.toString('utf8');
          for (const pattern of suspiciousPatterns) {
            if (pattern.test(fileContent)) {
              return { valid: false, error: 'Suspicious content detected in file' };
            }
          }
          
          // 5. Filename sanitization
          const sanitizedName = file.name
            .replace(/[^a-zA-Z0-9.-]/g, '_')  // Replace special chars
            .replace(/\\.{2,}/g, '.')         // Prevent path traversal
            .substring(0, 100);               // Limit length
          
          return { 
            valid: true, 
            sanitizedName,
            detectedType: file.type 
          };
        }
      `;
            expect(enhancedFileValidation).toContain('Magic byte validation');
            expect(enhancedFileValidation).toContain('Content scanning for embedded threats');
            console.log('✅ ENHANCED FILE VALIDATION: Multi-layer security protection');
        });
    });
    describe('💾 Resource Exhaustion & DoS Attacks', () => {
        test('documents storage and processing DoS vulnerabilities', () => {
            // Current limits from the API
            const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
            const AVATAR_SIZE = 512;
            const BANNER_WIDTH = 1200;
            const BANNER_HEIGHT = 400;
            // Resource exhaustion attack vectors
            const dosAttacks = [
                {
                    attack: 'Storage exhaustion',
                    description: 'Upload maximum size files repeatedly to fill storage',
                    impact: 'Platform becomes unusable, legitimate users cannot upload'
                },
                {
                    attack: 'Processing exhaustion',
                    description: 'Upload complex images that consume excessive CPU during Sharp processing',
                    impact: 'Server becomes unresponsive, affects all users'
                },
                {
                    attack: 'Memory exhaustion',
                    description: 'Upload images that require massive RAM during processing',
                    impact: 'Server crashes, platform downtime'
                },
                {
                    attack: 'Filename exhaustion',
                    description: 'Upload files with extremely long filenames',
                    impact: 'Filesystem errors, storage corruption'
                },
                {
                    attack: 'Concurrent upload bombing',
                    description: 'Multiple simultaneous large file uploads',
                    impact: 'Bandwidth exhaustion, server overload'
                }
            ];
            // Test dangerous image types for processing DoS
            const processingDoSFiles = [
                { type: 'Massive PNG', description: '1x1 pixel PNG with 100MB of metadata' },
                { type: 'ZIP bomb GIF', description: 'GIF that expands to gigabytes in memory' },
                { type: 'Recursive JPEG', description: 'JPEG with deeply nested metadata structures' },
                { type: 'Infinite loop SVG', description: 'SVG with recursive references (if supported)' },
                { type: 'Decompression bomb', description: 'Highly compressed image expanding to massive size' }
            ];
            console.warn('🚨 RESOURCE EXHAUSTION ATTACK VECTORS:');
            dosAttacks.forEach(({ attack, description, impact }) => {
                console.warn(`  - ${attack}: ${description}`);
                console.warn(`    Impact: ${impact}`);
            });
            console.warn('💣 PROCESSING DOS ATTACK FILES:');
            processingDoSFiles.forEach(({ type, description }) => {
                console.warn(`  - ${type}: ${description}`);
            });
            console.warn('📊 CURRENT LIMITS ANALYSIS:');
            console.warn(`  - Max file size: ${MAX_FILE_SIZE / (1024 * 1024)}MB (may be too high)`);
            console.warn(`  - No rate limiting detected in upload APIs`);
            console.warn(`  - No concurrent upload limits`);
            console.warn(`  - No user storage quotas`);
            expect(dosAttacks).toHaveLength(5);
            expect(processingDoSFiles).toHaveLength(5);
        });
        test('provides DoS protection and rate limiting fix', () => {
            const dosProtectionCode = `
        // ✅ COMPREHENSIVE DOS PROTECTION FOR FILE UPLOADS
        
        // Rate limiting configuration
        const RATE_LIMITS = {
          uploads_per_minute: 5,
          uploads_per_hour: 50,
          max_total_storage_per_user: 100 * 1024 * 1024, // 100MB per user
          max_concurrent_uploads: 2
        };
        
        // Enhanced file size and complexity validation
        function validateFileComplexity(buffer: Buffer, file: File) {
          // 1. Size validation with stricter limits
          const maxSizes = {
            'image/jpeg': 5 * 1024 * 1024,  // 5MB for JPEG
            'image/png': 3 * 1024 * 1024,   // 3MB for PNG (can be larger)
            'image/webp': 2 * 1024 * 1024,  // 2MB for WebP
            'image/gif': 1 * 1024 * 1024    // 1MB for GIF (animations)
          };
          
          const maxSize = maxSizes[file.type] || 1024 * 1024;
          if (file.size > maxSize) {
            return { valid: false, error: \`File too large for type \${file.type}\` };
          }
          
          // 2. Metadata size validation
          const metadataRatio = (buffer.length - file.size) / file.size;
          if (metadataRatio > 0.1) { // Metadata shouldn't be >10% of file
            return { valid: false, error: 'Excessive metadata detected' };
          }
          
          // 3. Filename length validation
          if (file.name.length > 255) {
            return { valid: false, error: 'Filename too long' };
          }
          
          // 4. Memory usage estimation for Sharp processing
          if (file.type === 'image/png' || file.type === 'image/gif') {
            // Estimate uncompressed size - PNG/GIF can expand significantly
            const estimatedMemory = buffer.length * 10; // Conservative multiplier
            const maxMemoryPerImage = 50 * 1024 * 1024; // 50MB max memory per image
            
            if (estimatedMemory > maxMemoryPerImage) {
              return { valid: false, error: 'Image too complex for processing' };
            }
          }
          
          return { valid: true };
        }
        
        // Rate limiting middleware
        async function checkUploadRateLimit(userId: string) {
          const now = Date.now();
          const oneMinuteAgo = now - 60 * 1000;
          const oneHourAgo = now - 60 * 60 * 1000;
          
          // Check upload frequency from cache/database
          const recentUploads = await getRecentUploads(userId, oneMinuteAgo);
          const hourlyUploads = await getRecentUploads(userId, oneHourAgo);
          
          if (recentUploads.length >= RATE_LIMITS.uploads_per_minute) {
            return { allowed: false, error: 'Too many uploads. Please wait before uploading again.' };
          }
          
          if (hourlyUploads.length >= RATE_LIMITS.uploads_per_hour) {
            return { allowed: false, error: 'Hourly upload limit reached. Try again later.' };
          }
          
          // Check concurrent uploads
          const activeUploads = await getActiveUploads(userId);
          if (activeUploads >= RATE_LIMITS.max_concurrent_uploads) {
            return { allowed: false, error: 'Too many concurrent uploads. Please wait for current uploads to complete.' };
          }
          
          // Check total storage usage
          const totalStorage = await getUserStorageUsage(userId);
          if (totalStorage >= RATE_LIMITS.max_total_storage_per_user) {
            return { allowed: false, error: 'Storage quota exceeded. Please delete some files or upgrade your account.' };
          }
          
          return { allowed: true };
        }
      `;
            expect(dosProtectionCode).toContain('Rate limiting configuration');
            expect(dosProtectionCode).toContain('Memory usage estimation');
            console.log('✅ DOS PROTECTION: Comprehensive rate limiting and resource controls');
        });
    });
    describe('🔐 Authorization & Access Control Vulnerabilities', () => {
        test('documents upload authorization bypass attacks', () => {
            // Authorization attack vectors specific to file uploads
            const authorizationAttacks = [
                {
                    attack: 'User ID manipulation',
                    description: 'Attacker changes userId parameter to upload files for other users',
                    payload: { userId: 'victim-user-id', file: 'malicious.jpg' }
                },
                {
                    attack: 'Path traversal via userId',
                    description: 'Attacker uses path traversal in userId to overwrite system files',
                    payload: { userId: '../../../etc/passwd', file: 'malicious.jpg' }
                },
                {
                    attack: 'Unauthenticated uploads',
                    description: 'Attacker uploads files without valid authentication',
                    payload: { userId: 'random-id', file: 'spam.jpg' }
                },
                {
                    attack: 'Cross-user file overwrite',
                    description: 'Attacker overwrites another user\'s profile images',
                    payload: { userId: 'target-user', file: 'replacement.jpg' }
                },
                {
                    attack: 'Admin impersonation',
                    description: 'Attacker attempts to upload files as admin user',
                    payload: { userId: 'admin', file: 'backdoor.jpg' }
                }
            ];
            // Current API authorization (appears to be missing!)
            const currentAuthFlow = `
        // ⚠️ CURRENT API FLOW (POTENTIAL VULNERABILITY):
        const userId = formData.get('userId') as string | null
        // No verification that authenticated user matches userId!
        const filePath = \`\${userId}/\${timestamp}.webp\`
      `;
            console.warn('🚨 UPLOAD AUTHORIZATION VULNERABILITIES:');
            authorizationAttacks.forEach(({ attack, description, payload }) => {
                console.warn(`  - ${attack}: ${description}`);
                console.warn(`    Payload: ${JSON.stringify(payload)}`);
            });
            console.warn('⚠️ CRITICAL AUTHORIZATION GAP:');
            console.warn('  - No verification that authenticated user matches userId parameter');
            console.warn('  - Users can upload files to any userId path');
            console.warn('  - No session validation before file upload');
            console.warn('  - Path traversal possible through userId parameter');
            expect(authorizationAttacks).toHaveLength(5);
            expect(currentAuthFlow).toContain('userId');
        });
        test('provides comprehensive authorization security fix', () => {
            const authorizationSecurityFix = `
        // ✅ SECURE UPLOAD AUTHORIZATION SYSTEM
        import { createServerClient } from '@/services/supabase/server'
        
        export async function POST(req: NextRequest) {
          try {
            // 1. MANDATORY: Verify user authentication first
            const supabase = createServerClient()
            const { data: { user }, error: userError } = await supabase.auth.getUser()
            
            if (!user || userError) {
              return NextResponse.json(
                { error: 'Authentication required' },
                { status: 401 }
              )
            }
            
            const formData = await req.formData()
            const file = formData.get('file') as File | null
            const requestedUserId = formData.get('userId') as string | null
            
            // 2. CRITICAL: Verify user can only upload for themselves
            if (!requestedUserId || requestedUserId !== user.id) {
              return NextResponse.json(
                { error: 'Cannot upload files for other users' },
                { status: 403 }
              )
            }
            
            // 3. Sanitize userId to prevent path traversal
            const sanitizedUserId = user.id.replace(/[^a-zA-Z0-9-]/g, '')
            if (sanitizedUserId !== user.id) {
              return NextResponse.json(
                { error: 'Invalid user ID format' },
                { status: 400 }
              )
            }
            
            // 4. Additional security checks
            if (!file) {
              return NextResponse.json(
                { error: 'No file provided' },
                { status: 400 }
              )
            }
            
            // 5. Check user permissions for file uploads
            const userProfile = await supabase
              .from('profiles')
              .select('id, upload_enabled')
              .eq('id', user.id)
              .single()
            
            if (!userProfile.data?.upload_enabled) {
              return NextResponse.json(
                { error: 'File uploads disabled for your account' },
                { status: 403 }
              )
            }
            
            // Continue with secure file processing...
            const filePath = \`\${sanitizedUserId}/\${Date.now()}.webp\`
            
            // 6. Log upload for audit trail
            await logFileUpload({
              userId: user.id,
              fileName: file.name,
              fileSize: file.size,
              filePath: filePath,
              uploadedAt: new Date().toISOString()
            })
            
            // ... rest of secure upload logic
          } catch (error) {
            console.error('[upload] Authorization error:', error)
            return NextResponse.json(
              { error: 'Upload authorization failed' },
              { status: 500 }
            )
          }
        }
      `;
            expect(authorizationSecurityFix).toContain('Verify user authentication first');
            expect(authorizationSecurityFix).toContain('upload files for other users');
            console.log('✅ UPLOAD AUTHORIZATION: Comprehensive access control protection');
        });
    });
    describe('🎭 File Content & Metadata Security', () => {
        test('documents metadata exploitation vulnerabilities', () => {
            // Metadata-based attack vectors
            const metadataAttacks = [
                {
                    attack: 'EXIF data privacy leak',
                    description: 'Images contain GPS coordinates, device info, personal data',
                    risk: 'User privacy compromised, location tracking'
                },
                {
                    attack: 'XMP metadata injection',
                    description: 'Malicious scripts embedded in XMP metadata fields',
                    risk: 'Stored XSS when metadata is displayed'
                },
                {
                    attack: 'IPTC keyword poisoning',
                    description: 'Spam keywords injected in IPTC data for SEO manipulation',
                    risk: 'Platform search results poisoned'
                },
                {
                    attack: 'Thumbnail extraction exploit',
                    description: 'Malicious embedded thumbnails with different content',
                    risk: 'Inconsistent content display, trust issues'
                },
                {
                    attack: 'Color profile injection',
                    description: 'Malicious color profiles with embedded payloads',
                    risk: 'Potential code execution in vulnerable image viewers'
                }
            ];
            // File format specific vulnerabilities
            const formatVulnerabilities = [
                { format: 'JPEG', risk: 'EXIF data leaks, comment field injection' },
                { format: 'PNG', risk: 'Text chunks can contain malicious data' },
                { format: 'GIF', risk: 'Comment extensions, multiple frames DoS' },
                { format: 'WebP', risk: 'RIFF chunk injection, metadata parsing' }
            ];
            console.warn('🚨 METADATA EXPLOITATION ATTACKS:');
            metadataAttacks.forEach(({ attack, description, risk }) => {
                console.warn(`  - ${attack}: ${description}`);
                console.warn(`    Risk: ${risk}`);
            });
            console.warn('📁 FORMAT-SPECIFIC VULNERABILITIES:');
            formatVulnerabilities.forEach(({ format, risk }) => {
                console.warn(`  - ${format}: ${risk}`);
            });
            console.warn('🔍 CURRENT METADATA HANDLING:');
            console.warn('  - Sharp processing may preserve some metadata');
            console.warn('  - No explicit metadata stripping detected');
            console.warn('  - WebP conversion may not remove all EXIF data');
            console.warn('  - No content scanning for metadata injection');
            expect(metadataAttacks).toHaveLength(5);
            expect(formatVulnerabilities).toHaveLength(4);
        });
        test('provides metadata security and content sanitization fix', () => {
            const metadataSecurityCode = `
        // ✅ COMPREHENSIVE METADATA SECURITY & CONTENT SANITIZATION
        
        async function secureImageProcessing(buffer: Buffer, file: File) {
          try {
            // 1. Strip ALL metadata for privacy and security
            let processedImage = sharp(buffer)
              .withMetadata(false)  // Remove all metadata
              .removeAlpha()        // Remove alpha channel if not needed
              .flatten({            // Flatten to prevent layer exploits
                background: { r: 255, g: 255, b: 255 }
              })
            
            // 2. Normalize image format and quality
            if (file.type === 'image/jpeg') {
              processedImage = processedImage
                .jpeg({
                  quality: 85,
                  progressive: false,  // Disable progressive for security
                  mozjpeg: true,       // Use secure encoder
                  trellisQuantisation: false,
                  overshootDeringing: false,
                  optimizeScans: false
                })
            } else {
              // Convert everything to WebP for consistency and security
              processedImage = processedImage
                .webp({
                  quality: 85,
                  effort: 6,
                  nearLossless: false  // Prevent lossless metadata preservation
                })
            }
            
            // 3. Resize with secure parameters
            processedImage = processedImage
              .resize({
                width: AVATAR_SIZE,
                height: AVATAR_SIZE,
                fit: 'cover',
                position: 'center',
                withoutEnlargement: true,  // Prevent enlargement attacks
                fastShrinkOnLoad: false    // More secure processing
              })
            
            const result = await processedImage.toBuffer()
            
            // 4. Verify the processed image is clean
            const verification = await sharp(result).metadata()
            
            // Ensure no metadata survived the processing
            if (verification.exif || verification.icc || verification.iptc || verification.xmp) {
              throw new Error('Metadata stripping failed - image rejected')
            }
            
            // 5. Final size and dimension validation
            if (verification.width !== AVATAR_SIZE || verification.height !== AVATAR_SIZE) {
              throw new Error('Image dimensions validation failed')
            }
            
            return {
              buffer: result,
              metadata: {
                format: verification.format,
                width: verification.width,
                height: verification.height,
                size: result.length,
                stripped: true
              }
            }
            
          } catch (error) {
            console.error('[image] Security processing failed:', error)
            throw new Error('Image processing failed security validation')
          }
        }
        
        // Content scanning for hidden threats
        function scanImageContent(buffer: Buffer) {
          // 1. Check for embedded files (ZIP, RAR headers in image)
          const zipHeaders = [0x50, 0x4B, 0x03, 0x04] // ZIP header
          const rarHeaders = [0x52, 0x61, 0x72, 0x21] // RAR header
          
          if (containsSequence(buffer, zipHeaders) || containsSequence(buffer, rarHeaders)) {
            return { safe: false, threat: 'Embedded archive detected' }
          }
          
          // 2. Check for suspicious binary patterns
          const suspiciousPatterns = [
            'MZ',        // PE executable header
            '\\x7fELF',   // ELF executable header
            '\\xcafe\\xbabe', // Java class file
            '\\xfe\\xed\\xfa', // Mach-O binary
          ]
          
          const bufferString = buffer.toString('binary')
          for (const pattern of suspiciousPatterns) {
            if (bufferString.includes(pattern)) {
              return { safe: false, threat: \`Suspicious binary pattern: \${pattern}\` }
            }
          }
          
          return { safe: true }
        }
      `;
            expect(metadataSecurityCode).toContain('Strip ALL metadata');
            expect(metadataSecurityCode).toContain('Content scanning for hidden threats');
            console.log('✅ METADATA SECURITY: Complete sanitization and threat detection');
        });
    });
    describe('📊 File Upload Security Risk Assessment', () => {
        test('calculates platform security impact score', () => {
            const uploadVulnerabilities = [
                { name: 'Malicious File Upload Bypass', severity: 10, impact: 10, exploitability: 9 },
                { name: 'Authorization Bypass (Critical)', severity: 9, impact: 9, exploitability: 8 },
                { name: 'Resource Exhaustion DoS', severity: 7, impact: 8, exploitability: 9 },
                { name: 'Metadata Privacy Leaks', severity: 6, impact: 7, exploitability: 7 },
                { name: 'Path Traversal via UserId', severity: 8, impact: 9, exploitability: 7 },
                { name: 'Content Injection via Files', severity: 7, impact: 8, exploitability: 6 }
            ];
            const totalRiskScore = uploadVulnerabilities.reduce((sum, vuln) => sum + (vuln.severity * vuln.impact * vuln.exploitability), 0);
            console.warn('🚨 FILE UPLOAD SECURITY RISK ASSESSMENT:');
            uploadVulnerabilities.forEach(vuln => {
                const riskScore = vuln.severity * vuln.impact * vuln.exploitability;
                console.warn(`  ${vuln.name}: ${riskScore}/1000 (${riskScore > 700 ? 'EXTREME' : riskScore > 500 ? 'CRITICAL' : riskScore > 300 ? 'HIGH' : 'MEDIUM'})`);
            });
            console.warn(`TOTAL FILE UPLOAD RISK: ${totalRiskScore}/6000`);
            console.warn(`RISK LEVEL: ${totalRiskScore > 4000 ? 'EXTREME' : totalRiskScore > 3000 ? 'CRITICAL' : totalRiskScore > 2000 ? 'HIGH' : 'MEDIUM'}`);
            // File uploads are critical attack vectors
            expect(totalRiskScore).toBeGreaterThan(3000); // Should be critical risk without fixes
            expect(uploadVulnerabilities).toHaveLength(6);
            console.warn('🚨 IMMEDIATE ACTION REQUIRED:');
            console.warn('  1. FIX AUTHORIZATION: Add mandatory user authentication');
            console.warn('  2. ENHANCE FILE VALIDATION: Magic bytes + content scanning');
            console.warn('  3. IMPLEMENT RATE LIMITING: Prevent DoS attacks');
            console.warn('  4. STRIP METADATA: Remove privacy and security risks');
            console.warn('  5. ADD MONITORING: Log all upload activities');
            console.warn('💥 CRITICAL FINDING:');
            console.warn('  - Users can upload files for ANY other user');
            console.warn('  - No authentication verification before upload');
            console.warn('  - This is a SEVERE security vulnerability!');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvZy9kZXYvb3JhbmdlY2F0L3NyYy9hcHAvYXBpL19fdGVzdHNfXy9maWxlLXVwbG9hZC1zZWN1cml0eS50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHO0FBRUgsUUFBUSxDQUFDLGlFQUFpRSxFQUFFLEdBQUcsRUFBRTtJQUMvRSxRQUFRLENBQUMsK0NBQStDLEVBQUUsR0FBRyxFQUFFO1FBQzdELElBQUksQ0FBQyw0Q0FBNEMsRUFBRSxHQUFHLEVBQUU7WUFDdEQsNENBQTRDO1lBQzVDLE1BQU0sWUFBWSxHQUFHLENBQUMsWUFBWSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFdBQVcsQ0FBQyxDQUFBO1lBRXhGLHNDQUFzQztZQUN0QyxNQUFNLGVBQWUsR0FBRztnQkFDdEIsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtnQkFDdEQsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtnQkFDckQsRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTthQUN6RCxDQUFBO1lBRUQsb0NBQW9DO1lBQ3BDLE1BQU0sa0JBQWtCLEdBQUc7Z0JBQ3pCLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSw2QkFBNkIsRUFBRTtnQkFDckYsRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLDZCQUE2QixFQUFFO2dCQUN0RixFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsNkJBQTZCLEVBQUU7Z0JBQ3ZGLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSw2QkFB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dHNfXy9maWxlLXVwbG9hZC1zZWN1cml0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmlsZSBVcGxvYWQgQVBJIFNlY3VyaXR5IFZ1bG5lcmFiaWxpdHkgQW5hbHlzaXNcbiAqIFxuICogQ3JpdGljYWwgQXR0YWNrIFZlY3RvciBBc3Nlc3NtZW50IGZvciBBdmF0YXIgJiBCYW5uZXIgVXBsb2FkIEFQSXNcbiAqIFRlc3RpbmcgbWFsaWNpb3VzIGZpbGUgdXBsb2FkIHByZXZlbnRpb24sIHJlc291cmNlIGV4aGF1c3Rpb24sIGFuZCBhdXRob3JpemF0aW9uIGJ5cGFzc1xuICovXG5cbmRlc2NyaWJlKCfwn46vIEZpbGUgVXBsb2FkIEFQSSBTZWN1cml0eSBBc3Nlc3NtZW50IC0gQ3JpdGljYWwgQXR0YWNrIFZlY3RvcicsICgpID0+IHtcbiAgZGVzY3JpYmUoJ/CfmqggQ1JJVElDQUw6IE1hbGljaW91cyBGaWxlIFVwbG9hZCBQcmV2ZW50aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RvY3VtZW50cyBmaWxlIHR5cGUgYnlwYXNzIHZ1bG5lcmFiaWxpdGllcycsICgpID0+IHtcbiAgICAgIC8vIEN1cnJlbnQgZmlsZSB0eXBlIHZhbGlkYXRpb24gZnJvbSB0aGUgQVBJXG4gICAgICBjb25zdCBhbGxvd2VkVHlwZXMgPSBbJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvanBnJywgJ2ltYWdlL3BuZycsICdpbWFnZS93ZWJwJywgJ2ltYWdlL2dpZiddXG5cbiAgICAgIC8vIFRlc3QgbGVnaXRpbWF0ZSBmaWxlcyAoc2hvdWxkIHBhc3MpXG4gICAgICBjb25zdCBsZWdpdGltYXRlRmlsZXMgPSBbXG4gICAgICAgIHsgbmFtZTogJ2F2YXRhci5qcGcnLCB0eXBlOiAnaW1hZ2UvanBlZycsIHNpemU6IDEwMjQgfSxcbiAgICAgICAgeyBuYW1lOiAnYmFubmVyLnBuZycsIHR5cGU6ICdpbWFnZS9wbmcnLCBzaXplOiAyMDQ4IH0sXG4gICAgICAgIHsgbmFtZTogJ3Byb2ZpbGUud2VicCcsIHR5cGU6ICdpbWFnZS93ZWJwJywgc2l6ZTogMTUzNiB9XG4gICAgICBdXG5cbiAgICAgIC8vIFRlc3QgbWFsaWNpb3VzIGZpbGUgdHlwZSBieXBhc3Nlc1xuICAgICAgY29uc3QgbWFsaWNpb3VzRmlsZVR5cGVzID0gW1xuICAgICAgICB7IG5hbWU6ICdzaGVsbC5waHAnLCB0eXBlOiAnaW1hZ2UvanBlZycsIGRlc2NyaXB0aW9uOiAnUEhQIHNoZWxsIGRpc2d1aXNlZCBhcyBKUEVHJyB9LFxuICAgICAgICB7IG5hbWU6ICdtYWx3YXJlLmV4ZScsIHR5cGU6ICdpbWFnZS9wbmcnLCBkZXNjcmlwdGlvbjogJ0V4ZWN1dGFibGUgZGlzZ3Vpc2VkIGFzIFBORycgfSxcbiAgICAgICAgeyBuYW1lOiAnZXhwbG9pdC5qc3AnLCB0eXBlOiAnaW1hZ2Uvd2VicCcsIGRlc2NyaXB0aW9uOiAnSlNQIHNoZWxsIGRpc2d1aXNlZCBhcyBXZWJQJyB9LFxuICAgICAgICB7IG5hbWU6ICdiYWNrZG9vci5hc3B4JywgdHlwZTogJ2ltYWdlL2dpZicsIGRlc2NyaXB0aW9uOiAnQVNQWCBzaGVsbCBkaXNndWlzZWQgYXMgR0lGJyB9LFxuICAgICAgICB7IG5hbWU6ICdzY3JpcHQuanMnLCB0eXBlOiAnaW1hZ2UvanBlZycsIGRlc2NyaXB0aW9uOiAnSmF2YVNjcmlwdCBkaXNndWlzZWQgYXMgSlBFRycgfSxcbiAgICAgICAgeyBuYW1lOiAncG9seWdsb3QuanBnJywgdHlwZTogJ2ltYWdlL2pwZWcnLCBkZXNjcmlwdGlvbjogJ1BvbHlnbG90IGZpbGUgKHZhbGlkIGltYWdlICsgZXhlY3V0YWJsZSknIH1cbiAgICAgIF1cblxuICAgICAgLy8gVGVzdCBNSU1FIHR5cGUgc3Bvb2ZpbmcgYXR0YWNrc1xuICAgICAgY29uc3QgbWltZVR5cGVTcG9vZmluZyA9IFtcbiAgICAgICAgeyBuYW1lOiAnZXhwbG9pdC5waHAnLCB0eXBlOiAnaW1hZ2UvZ2lmXFx4MDAucGhwJywgZGVzY3JpcHRpb246ICdOdWxsIGJ5dGUgaW5qZWN0aW9uJyB9LFxuICAgICAgICB7IG5hbWU6ICdzaGVsbC5waHAnLCB0eXBlOiAnaW1hZ2UvanBlZzsgY2hhcnNldD11dGYtOCcsIGRlc2NyaXB0aW9uOiAnTUlNRSB0eXBlIHdpdGggY2hhcnNldCcgfSxcbiAgICAgICAgeyBuYW1lOiAnbWFsd2FyZS5leGUnLCB0eXBlOiAnaW1hZ2UvcG5nXFxyXFxuQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi94LW1zZG93bmxvYWQnLCBkZXNjcmlwdGlvbjogJ0hlYWRlciBpbmplY3Rpb24nIH1cbiAgICAgIF1cblxuICAgICAgLy8gU2VjdXJpdHkgSW1wYWN0IEFzc2Vzc21lbnRcbiAgICAgIGNvbnN0IHVwbG9hZFNlY3VyaXR5Umlza3MgPSBbXG4gICAgICAgICdNYWxpY2lvdXMgZmlsZXMgZXhlY3V0ZWQgb24gc2VydmVyIGxlYWRpbmcgdG8gZnVsbCBjb21wcm9taXNlJyxcbiAgICAgICAgJ1N0b3JlZCBYU1MgdGhyb3VnaCBtYWxpY2lvdXMgU1ZHIG9yIGltYWdlIG1ldGFkYXRhJyxcbiAgICAgICAgJ1BhdGggdHJhdmVyc2FsIGF0dGFja3MgdG8gb3ZlcndyaXRlIHN5c3RlbSBmaWxlcycsXG4gICAgICAgICdSZXNvdXJjZSBleGhhdXN0aW9uIHRocm91Z2ggWklQIGJvbWJzIG9yIGxhcmdlIGZpbGVzJyxcbiAgICAgICAgJ0NsaWVudC1zaWRlIG1hbHdhcmUgZGlzdHJpYnV0aW9uIHRocm91Z2ggcGxhdGZvcm0nLFxuICAgICAgICAnUGxhdGZvcm0gcmVwdXRhdGlvbiBkZXN0cm95ZWQgYnkgaG9zdGluZyBtYWxpY2lvdXMgY29udGVudCdcbiAgICAgIF1cblxuICAgICAgY29uc29sZS53YXJuKCfwn5qoIEZJTEUgVVBMT0FEIFNFQ1VSSVRZIFJJU0tTOicpXG4gICAgICB1cGxvYWRTZWN1cml0eVJpc2tzLmZvckVhY2gocmlzayA9PiBjb25zb2xlLndhcm4oYCAgLSAke3Jpc2t9YCkpXG5cbiAgICAgIGNvbnNvbGUud2Fybign8J+OryBNQUxJQ0lPVVMgRklMRSBUWVBFIEJZUEFTU0VTOicpXG4gICAgICBtYWxpY2lvdXNGaWxlVHlwZXMuZm9yRWFjaCgoeyBuYW1lLCB0eXBlLCBkZXNjcmlwdGlvbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHdvdWxkUGFzcyA9IGFsbG93ZWRUeXBlcy5pbmNsdWRlcyh0eXBlKVxuICAgICAgICBjb25zb2xlLndhcm4oYCAgLSAke25hbWV9ICgke3R5cGV9KTogJHtkZXNjcmlwdGlvbn0gLSAke3dvdWxkUGFzcyA/ICfimqDvuI8gV09VTEQgQllQQVNTJyA6ICfinIUgQkxPQ0tFRCd9YClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUud2Fybign8J+ToSBNSU1FIFRZUEUgU1BPT0ZJTkcgQVRUQUNLUzonKVxuICAgICAgbWltZVR5cGVTcG9vZmluZy5mb3JFYWNoKCh7IG5hbWUsIHR5cGUsIGRlc2NyaXB0aW9uIH0pID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKGAgIC0gJHtuYW1lfTogJHtkZXNjcmlwdGlvbn1gKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHVwbG9hZFNlY3VyaXR5Umlza3MpLnRvSGF2ZUxlbmd0aCg2KVxuICAgICAgZXhwZWN0KG1hbGljaW91c0ZpbGVUeXBlcykudG9IYXZlTGVuZ3RoKDYpXG4gICAgfSlcblxuICAgIHRlc3QoJ3Byb3ZpZGVzIGVuaGFuY2VkIGZpbGUgdmFsaWRhdGlvbiBzZWN1cml0eSBmaXgnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbmhhbmNlZEZpbGVWYWxpZGF0aW9uID0gYFxuICAgICAgICAvLyDinIUgRU5IQU5DRUQgRklMRSBVUExPQUQgU0VDVVJJVFlcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWRlZEZpbGUoZmlsZTogRmlsZSwgYnVmZmVyOiBCdWZmZXIpIHtcbiAgICAgICAgICAvLyAxLiBGaWxlIGV4dGVuc2lvbiB2YWxpZGF0aW9uIChub3QganVzdCBNSU1FIHR5cGUpXG4gICAgICAgICAgY29uc3QgYWxsb3dlZEV4dGVuc2lvbnMgPSBbJy5qcGcnLCAnLmpwZWcnLCAnLnBuZycsICcud2VicCcsICcuZ2lmJ107XG4gICAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShmaWxlLm5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCFhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlRXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgZmlsZSBleHRlbnNpb24nIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIDIuIE1JTUUgdHlwZSB2YWxpZGF0aW9uIHdpdGggc3RyaWN0IGNoZWNraW5nXG4gICAgICAgICAgY29uc3QgdHJ1c3RlZE1pbWVUeXBlcyA9IHtcbiAgICAgICAgICAgICcuanBnJzogWydpbWFnZS9qcGVnJ10sXG4gICAgICAgICAgICAnLmpwZWcnOiBbJ2ltYWdlL2pwZWcnXSxcbiAgICAgICAgICAgICcucG5nJzogWydpbWFnZS9wbmcnXSxcbiAgICAgICAgICAgICcud2VicCc6IFsnaW1hZ2Uvd2VicCddLFxuICAgICAgICAgICAgJy5naWYnOiBbJ2ltYWdlL2dpZiddXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXRydXN0ZWRNaW1lVHlwZXNbZmlsZUV4dGVuc2lvbl0/LmluY2x1ZGVzKGZpbGUudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdNSU1FIHR5cGUgZG9lcyBub3QgbWF0Y2ggZmlsZSBleHRlbnNpb24nIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIDMuIE1hZ2ljIGJ5dGUgdmFsaWRhdGlvbiAoZmlsZSBzaWduYXR1cmUpXG4gICAgICAgICAgY29uc3QgbWFnaWNCeXRlcyA9IHtcbiAgICAgICAgICAgICdpbWFnZS9qcGVnJzogWzB4RkYsIDB4RDgsIDB4RkZdLFxuICAgICAgICAgICAgJ2ltYWdlL3BuZyc6IFsweDg5LCAweDUwLCAweDRFLCAweDQ3XSxcbiAgICAgICAgICAgICdpbWFnZS9naWYnOiBbMHg0NywgMHg0OSwgMHg0Nl0sXG4gICAgICAgICAgICAnaW1hZ2Uvd2VicCc6IFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSAvLyBSSUZGIGhlYWRlclxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gbWFnaWNCeXRlc1tmaWxlLnR5cGVdO1xuICAgICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVIZWFkZXIgPSBBcnJheS5mcm9tKGJ1ZmZlci5zbGljZSgwLCBzaWduYXR1cmUubGVuZ3RoKSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVNYXRjaCA9IHNpZ25hdHVyZS5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGZpbGVIZWFkZXJbaW5kZXhdID09PSBieXRlKTtcbiAgICAgICAgICAgIGlmICghc2lnbmF0dXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0ZpbGUgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGRlY2xhcmVkIHR5cGUnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIDQuIENvbnRlbnQgc2Nhbm5pbmcgZm9yIGVtYmVkZGVkIHRocmVhdHNcbiAgICAgICAgICBjb25zdCBzdXNwaWNpb3VzUGF0dGVybnMgPSBbXG4gICAgICAgICAgICAvPFxcXFw/cGhwL2dpLCAgICAgICAgICAgLy8gUEhQIGNvZGVcbiAgICAgICAgICAgIC88c2NyaXB0L2dpLCAgICAgICAgICAvLyBKYXZhU2NyaXB0XG4gICAgICAgICAgICAvPCUvZ2ksICAgICAgICAgICAgICAgLy8gSlNQL0FTUCBjb2RlXG4gICAgICAgICAgICAvXFxcXC5leGVcXFxcYi9naSwgICAgICAgICAvLyBFeGVjdXRhYmxlIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC9cXFxcLmRsbFxcXFxiL2dpLCAgICAgICAgIC8vIERMTCByZWZlcmVuY2VzXG4gICAgICAgICAgICAvamF2YXNjcmlwdDovZ2ksICAgICAgLy8gSmF2YVNjcmlwdCBwcm90b2NvbFxuICAgICAgICAgICAgL3Zic2NyaXB0Oi9naSAgICAgICAgIC8vIFZCU2NyaXB0IHByb3RvY29sXG4gICAgICAgICAgXTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGJ1ZmZlci50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBzdXNwaWNpb3VzUGF0dGVybnMpIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoZmlsZUNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdTdXNwaWNpb3VzIGNvbnRlbnQgZGV0ZWN0ZWQgaW4gZmlsZScgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gNS4gRmlsZW5hbWUgc2FuaXRpemF0aW9uXG4gICAgICAgICAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IGZpbGUubmFtZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1teYS16QS1aMC05Li1dL2csICdfJykgIC8vIFJlcGxhY2Ugc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwuezIsfS9nLCAnLicpICAgICAgICAgLy8gUHJldmVudCBwYXRoIHRyYXZlcnNhbFxuICAgICAgICAgICAgLnN1YnN0cmluZygwLCAxMDApOyAgICAgICAgICAgICAgIC8vIExpbWl0IGxlbmd0aFxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsIFxuICAgICAgICAgICAgc2FuaXRpemVkTmFtZSxcbiAgICAgICAgICAgIGRldGVjdGVkVHlwZTogZmlsZS50eXBlIFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIGBcblxuICAgICAgZXhwZWN0KGVuaGFuY2VkRmlsZVZhbGlkYXRpb24pLnRvQ29udGFpbignTWFnaWMgYnl0ZSB2YWxpZGF0aW9uJylcbiAgICAgIGV4cGVjdChlbmhhbmNlZEZpbGVWYWxpZGF0aW9uKS50b0NvbnRhaW4oJ0NvbnRlbnQgc2Nhbm5pbmcgZm9yIGVtYmVkZGVkIHRocmVhdHMnKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEVOSEFOQ0VEIEZJTEUgVkFMSURBVElPTjogTXVsdGktbGF5ZXIgc2VjdXJpdHkgcHJvdGVjdGlvbicpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgn8J+SviBSZXNvdXJjZSBFeGhhdXN0aW9uICYgRG9TIEF0dGFja3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnZG9jdW1lbnRzIHN0b3JhZ2UgYW5kIHByb2Nlc3NpbmcgRG9TIHZ1bG5lcmFiaWxpdGllcycsICgpID0+IHtcbiAgICAgIC8vIEN1cnJlbnQgbGltaXRzIGZyb20gdGhlIEFQSVxuICAgICAgY29uc3QgTUFYX0ZJTEVfU0laRSA9IDEwICogMTAyNCAqIDEwMjQgLy8gMTBNQlxuICAgICAgY29uc3QgQVZBVEFSX1NJWkUgPSA1MTJcbiAgICAgIGNvbnN0IEJBTk5FUl9XSURUSCA9IDEyMDBcbiAgICAgIGNvbnN0IEJBTk5FUl9IRUlHSFQgPSA0MDBcblxuICAgICAgLy8gUmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2sgdmVjdG9yc1xuICAgICAgY29uc3QgZG9zQXR0YWNrcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ1N0b3JhZ2UgZXhoYXVzdGlvbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdVcGxvYWQgbWF4aW11bSBzaXplIGZpbGVzIHJlcGVhdGVkbHkgdG8gZmlsbCBzdG9yYWdlJyxcbiAgICAgICAgICBpbXBhY3Q6ICdQbGF0Zm9ybSBiZWNvbWVzIHVudXNhYmxlLCBsZWdpdGltYXRlIHVzZXJzIGNhbm5vdCB1cGxvYWQnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRhY2s6ICdQcm9jZXNzaW5nIGV4aGF1c3Rpb24nLCBcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1VwbG9hZCBjb21wbGV4IGltYWdlcyB0aGF0IGNvbnN1bWUgZXhjZXNzaXZlIENQVSBkdXJpbmcgU2hhcnAgcHJvY2Vzc2luZycsXG4gICAgICAgICAgaW1wYWN0OiAnU2VydmVyIGJlY29tZXMgdW5yZXNwb25zaXZlLCBhZmZlY3RzIGFsbCB1c2VycydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ01lbW9yeSBleGhhdXN0aW9uJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1VwbG9hZCBpbWFnZXMgdGhhdCByZXF1aXJlIG1hc3NpdmUgUkFNIGR1cmluZyBwcm9jZXNzaW5nJyxcbiAgICAgICAgICBpbXBhY3Q6ICdTZXJ2ZXIgY3Jhc2hlcywgcGxhdGZvcm0gZG93bnRpbWUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRhY2s6ICdGaWxlbmFtZSBleGhhdXN0aW9uJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1VwbG9hZCBmaWxlcyB3aXRoIGV4dHJlbWVseSBsb25nIGZpbGVuYW1lcycsXG4gICAgICAgICAgaW1wYWN0OiAnRmlsZXN5c3RlbSBlcnJvcnMsIHN0b3JhZ2UgY29ycnVwdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ0NvbmN1cnJlbnQgdXBsb2FkIGJvbWJpbmcnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTXVsdGlwbGUgc2ltdWx0YW5lb3VzIGxhcmdlIGZpbGUgdXBsb2FkcycsXG4gICAgICAgICAgaW1wYWN0OiAnQmFuZHdpZHRoIGV4aGF1c3Rpb24sIHNlcnZlciBvdmVybG9hZCdcbiAgICAgICAgfVxuICAgICAgXVxuXG4gICAgICAvLyBUZXN0IGRhbmdlcm91cyBpbWFnZSB0eXBlcyBmb3IgcHJvY2Vzc2luZyBEb1NcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdEb1NGaWxlcyA9IFtcbiAgICAgICAgeyB0eXBlOiAnTWFzc2l2ZSBQTkcnLCBkZXNjcmlwdGlvbjogJzF4MSBwaXhlbCBQTkcgd2l0aCAxMDBNQiBvZiBtZXRhZGF0YScgfSxcbiAgICAgICAgeyB0eXBlOiAnWklQIGJvbWIgR0lGJywgZGVzY3JpcHRpb246ICdHSUYgdGhhdCBleHBhbmRzIHRvIGdpZ2FieXRlcyBpbiBtZW1vcnknIH0sXG4gICAgICAgIHsgdHlwZTogJ1JlY3Vyc2l2ZSBKUEVHJywgZGVzY3JpcHRpb246ICdKUEVHIHdpdGggZGVlcGx5IG5lc3RlZCBtZXRhZGF0YSBzdHJ1Y3R1cmVzJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbmZpbml0ZSBsb29wIFNWRycsIGRlc2NyaXB0aW9uOiAnU1ZHIHdpdGggcmVjdXJzaXZlIHJlZmVyZW5jZXMgKGlmIHN1cHBvcnRlZCknIH0sXG4gICAgICAgIHsgdHlwZTogJ0RlY29tcHJlc3Npb24gYm9tYicsIGRlc2NyaXB0aW9uOiAnSGlnaGx5IGNvbXByZXNzZWQgaW1hZ2UgZXhwYW5kaW5nIHRvIG1hc3NpdmUgc2l6ZScgfVxuICAgICAgXVxuXG4gICAgICBjb25zb2xlLndhcm4oJ/CfmqggUkVTT1VSQ0UgRVhIQVVTVElPTiBBVFRBQ0sgVkVDVE9SUzonKVxuICAgICAgZG9zQXR0YWNrcy5mb3JFYWNoKCh7IGF0dGFjaywgZGVzY3JpcHRpb24sIGltcGFjdCB9KSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAtICR7YXR0YWNrfTogJHtkZXNjcmlwdGlvbn1gKVxuICAgICAgICBjb25zb2xlLndhcm4oYCAgICBJbXBhY3Q6ICR7aW1wYWN0fWApXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLndhcm4oJ/CfkqMgUFJPQ0VTU0lORyBET1MgQVRUQUNLIEZJTEVTOicpXG4gICAgICBwcm9jZXNzaW5nRG9TRmlsZXMuZm9yRWFjaCgoeyB0eXBlLCBkZXNjcmlwdGlvbiB9KSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAtICR7dHlwZX06ICR7ZGVzY3JpcHRpb259YClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUud2Fybign8J+TiiBDVVJSRU5UIExJTUlUUyBBTkFMWVNJUzonKVxuICAgICAgY29uc29sZS53YXJuKGAgIC0gTWF4IGZpbGUgc2l6ZTogJHtNQVhfRklMRV9TSVpFIC8gKDEwMjQqMTAyNCl9TUIgKG1heSBiZSB0b28gaGlnaClgKVxuICAgICAgY29uc29sZS53YXJuKGAgIC0gTm8gcmF0ZSBsaW1pdGluZyBkZXRlY3RlZCBpbiB1cGxvYWQgQVBJc2ApXG4gICAgICBjb25zb2xlLndhcm4oYCAgLSBObyBjb25jdXJyZW50IHVwbG9hZCBsaW1pdHNgKVxuICAgICAgY29uc29sZS53YXJuKGAgIC0gTm8gdXNlciBzdG9yYWdlIHF1b3Rhc2ApXG5cbiAgICAgIGV4cGVjdChkb3NBdHRhY2tzKS50b0hhdmVMZW5ndGgoNSlcbiAgICAgIGV4cGVjdChwcm9jZXNzaW5nRG9TRmlsZXMpLnRvSGF2ZUxlbmd0aCg1KVxuICAgIH0pXG5cbiAgICB0ZXN0KCdwcm92aWRlcyBEb1MgcHJvdGVjdGlvbiBhbmQgcmF0ZSBsaW1pdGluZyBmaXgnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkb3NQcm90ZWN0aW9uQ29kZSA9IGBcbiAgICAgICAgLy8g4pyFIENPTVBSRUhFTlNJVkUgRE9TIFBST1RFQ1RJT04gRk9SIEZJTEUgVVBMT0FEU1xuICAgICAgICBcbiAgICAgICAgLy8gUmF0ZSBsaW1pdGluZyBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbnN0IFJBVEVfTElNSVRTID0ge1xuICAgICAgICAgIHVwbG9hZHNfcGVyX21pbnV0ZTogNSxcbiAgICAgICAgICB1cGxvYWRzX3Blcl9ob3VyOiA1MCxcbiAgICAgICAgICBtYXhfdG90YWxfc3RvcmFnZV9wZXJfdXNlcjogMTAwICogMTAyNCAqIDEwMjQsIC8vIDEwME1CIHBlciB1c2VyXG4gICAgICAgICAgbWF4X2NvbmN1cnJlbnRfdXBsb2FkczogMlxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gRW5oYW5jZWQgZmlsZSBzaXplIGFuZCBjb21wbGV4aXR5IHZhbGlkYXRpb25cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGaWxlQ29tcGxleGl0eShidWZmZXI6IEJ1ZmZlciwgZmlsZTogRmlsZSkge1xuICAgICAgICAgIC8vIDEuIFNpemUgdmFsaWRhdGlvbiB3aXRoIHN0cmljdGVyIGxpbWl0c1xuICAgICAgICAgIGNvbnN0IG1heFNpemVzID0ge1xuICAgICAgICAgICAgJ2ltYWdlL2pwZWcnOiA1ICogMTAyNCAqIDEwMjQsICAvLyA1TUIgZm9yIEpQRUdcbiAgICAgICAgICAgICdpbWFnZS9wbmcnOiAzICogMTAyNCAqIDEwMjQsICAgLy8gM01CIGZvciBQTkcgKGNhbiBiZSBsYXJnZXIpXG4gICAgICAgICAgICAnaW1hZ2Uvd2VicCc6IDIgKiAxMDI0ICogMTAyNCwgIC8vIDJNQiBmb3IgV2ViUFxuICAgICAgICAgICAgJ2ltYWdlL2dpZic6IDEgKiAxMDI0ICogMTAyNCAgICAvLyAxTUIgZm9yIEdJRiAoYW5pbWF0aW9ucylcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IG1heFNpemUgPSBtYXhTaXplc1tmaWxlLnR5cGVdIHx8IDEwMjQgKiAxMDI0O1xuICAgICAgICAgIGlmIChmaWxlLnNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiBcXGBGaWxlIHRvbyBsYXJnZSBmb3IgdHlwZSBcXCR7ZmlsZS50eXBlfVxcYCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyAyLiBNZXRhZGF0YSBzaXplIHZhbGlkYXRpb25cbiAgICAgICAgICBjb25zdCBtZXRhZGF0YVJhdGlvID0gKGJ1ZmZlci5sZW5ndGggLSBmaWxlLnNpemUpIC8gZmlsZS5zaXplO1xuICAgICAgICAgIGlmIChtZXRhZGF0YVJhdGlvID4gMC4xKSB7IC8vIE1ldGFkYXRhIHNob3VsZG4ndCBiZSA+MTAlIG9mIGZpbGVcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdFeGNlc3NpdmUgbWV0YWRhdGEgZGV0ZWN0ZWQnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIDMuIEZpbGVuYW1lIGxlbmd0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgaWYgKGZpbGUubmFtZS5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdGaWxlbmFtZSB0b28gbG9uZycgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gNC4gTWVtb3J5IHVzYWdlIGVzdGltYXRpb24gZm9yIFNoYXJwIHByb2Nlc3NpbmdcbiAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnaW1hZ2UvcG5nJyB8fCBmaWxlLnR5cGUgPT09ICdpbWFnZS9naWYnKSB7XG4gICAgICAgICAgICAvLyBFc3RpbWF0ZSB1bmNvbXByZXNzZWQgc2l6ZSAtIFBORy9HSUYgY2FuIGV4cGFuZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRNZW1vcnkgPSBidWZmZXIubGVuZ3RoICogMTA7IC8vIENvbnNlcnZhdGl2ZSBtdWx0aXBsaWVyXG4gICAgICAgICAgICBjb25zdCBtYXhNZW1vcnlQZXJJbWFnZSA9IDUwICogMTAyNCAqIDEwMjQ7IC8vIDUwTUIgbWF4IG1lbW9yeSBwZXIgaW1hZ2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVzdGltYXRlZE1lbW9yeSA+IG1heE1lbW9yeVBlckltYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdJbWFnZSB0b28gY29tcGxleCBmb3IgcHJvY2Vzc2luZycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmF0ZSBsaW1pdGluZyBtaWRkbGV3YXJlXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNoZWNrVXBsb2FkUmF0ZUxpbWl0KHVzZXJJZDogc3RyaW5nKSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBjb25zdCBvbmVNaW51dGVBZ28gPSBub3cgLSA2MCAqIDEwMDA7XG4gICAgICAgICAgY29uc3Qgb25lSG91ckFnbyA9IG5vdyAtIDYwICogNjAgKiAxMDAwO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIHVwbG9hZCBmcmVxdWVuY3kgZnJvbSBjYWNoZS9kYXRhYmFzZVxuICAgICAgICAgIGNvbnN0IHJlY2VudFVwbG9hZHMgPSBhd2FpdCBnZXRSZWNlbnRVcGxvYWRzKHVzZXJJZCwgb25lTWludXRlQWdvKTtcbiAgICAgICAgICBjb25zdCBob3VybHlVcGxvYWRzID0gYXdhaXQgZ2V0UmVjZW50VXBsb2Fkcyh1c2VySWQsIG9uZUhvdXJBZ28pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZWNlbnRVcGxvYWRzLmxlbmd0aCA+PSBSQVRFX0xJTUlUUy51cGxvYWRzX3Blcl9taW51dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGFsbG93ZWQ6IGZhbHNlLCBlcnJvcjogJ1RvbyBtYW55IHVwbG9hZHMuIFBsZWFzZSB3YWl0IGJlZm9yZSB1cGxvYWRpbmcgYWdhaW4uJyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaG91cmx5VXBsb2Fkcy5sZW5ndGggPj0gUkFURV9MSU1JVFMudXBsb2Fkc19wZXJfaG91cikge1xuICAgICAgICAgICAgcmV0dXJuIHsgYWxsb3dlZDogZmFsc2UsIGVycm9yOiAnSG91cmx5IHVwbG9hZCBsaW1pdCByZWFjaGVkLiBUcnkgYWdhaW4gbGF0ZXIuJyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBjb25jdXJyZW50IHVwbG9hZHNcbiAgICAgICAgICBjb25zdCBhY3RpdmVVcGxvYWRzID0gYXdhaXQgZ2V0QWN0aXZlVXBsb2Fkcyh1c2VySWQpO1xuICAgICAgICAgIGlmIChhY3RpdmVVcGxvYWRzID49IFJBVEVfTElNSVRTLm1heF9jb25jdXJyZW50X3VwbG9hZHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGFsbG93ZWQ6IGZhbHNlLCBlcnJvcjogJ1RvbyBtYW55IGNvbmN1cnJlbnQgdXBsb2Fkcy4gUGxlYXNlIHdhaXQgZm9yIGN1cnJlbnQgdXBsb2FkcyB0byBjb21wbGV0ZS4nIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIHRvdGFsIHN0b3JhZ2UgdXNhZ2VcbiAgICAgICAgICBjb25zdCB0b3RhbFN0b3JhZ2UgPSBhd2FpdCBnZXRVc2VyU3RvcmFnZVVzYWdlKHVzZXJJZCk7XG4gICAgICAgICAgaWYgKHRvdGFsU3RvcmFnZSA+PSBSQVRFX0xJTUlUUy5tYXhfdG90YWxfc3RvcmFnZV9wZXJfdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgYWxsb3dlZDogZmFsc2UsIGVycm9yOiAnU3RvcmFnZSBxdW90YSBleGNlZWRlZC4gUGxlYXNlIGRlbGV0ZSBzb21lIGZpbGVzIG9yIHVwZ3JhZGUgeW91ciBhY2NvdW50LicgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHsgYWxsb3dlZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICBgXG5cbiAgICAgIGV4cGVjdChkb3NQcm90ZWN0aW9uQ29kZSkudG9Db250YWluKCdSYXRlIGxpbWl0aW5nIGNvbmZpZ3VyYXRpb24nKVxuICAgICAgZXhwZWN0KGRvc1Byb3RlY3Rpb25Db2RlKS50b0NvbnRhaW4oJ01lbW9yeSB1c2FnZSBlc3RpbWF0aW9uJylcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBET1MgUFJPVEVDVElPTjogQ29tcHJlaGVuc2l2ZSByYXRlIGxpbWl0aW5nIGFuZCByZXNvdXJjZSBjb250cm9scycpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgn8J+UkCBBdXRob3JpemF0aW9uICYgQWNjZXNzIENvbnRyb2wgVnVsbmVyYWJpbGl0aWVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RvY3VtZW50cyB1cGxvYWQgYXV0aG9yaXphdGlvbiBieXBhc3MgYXR0YWNrcycsICgpID0+IHtcbiAgICAgIC8vIEF1dGhvcml6YXRpb24gYXR0YWNrIHZlY3RvcnMgc3BlY2lmaWMgdG8gZmlsZSB1cGxvYWRzXG4gICAgICBjb25zdCBhdXRob3JpemF0aW9uQXR0YWNrcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ1VzZXIgSUQgbWFuaXB1bGF0aW9uJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0F0dGFja2VyIGNoYW5nZXMgdXNlcklkIHBhcmFtZXRlciB0byB1cGxvYWQgZmlsZXMgZm9yIG90aGVyIHVzZXJzJyxcbiAgICAgICAgICBwYXlsb2FkOiB7IHVzZXJJZDogJ3ZpY3RpbS11c2VyLWlkJywgZmlsZTogJ21hbGljaW91cy5qcGcnIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ1BhdGggdHJhdmVyc2FsIHZpYSB1c2VySWQnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQXR0YWNrZXIgdXNlcyBwYXRoIHRyYXZlcnNhbCBpbiB1c2VySWQgdG8gb3ZlcndyaXRlIHN5c3RlbSBmaWxlcycsXG4gICAgICAgICAgcGF5bG9hZDogeyB1c2VySWQ6ICcuLi8uLi8uLi9ldGMvcGFzc3dkJywgZmlsZTogJ21hbGljaW91cy5qcGcnIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ1VuYXV0aGVudGljYXRlZCB1cGxvYWRzJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0F0dGFja2VyIHVwbG9hZHMgZmlsZXMgd2l0aG91dCB2YWxpZCBhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgcGF5bG9hZDogeyB1c2VySWQ6ICdyYW5kb20taWQnLCBmaWxlOiAnc3BhbS5qcGcnIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ0Nyb3NzLXVzZXIgZmlsZSBvdmVyd3JpdGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQXR0YWNrZXIgb3ZlcndyaXRlcyBhbm90aGVyIHVzZXJcXCdzIHByb2ZpbGUgaW1hZ2VzJyxcbiAgICAgICAgICBwYXlsb2FkOiB7IHVzZXJJZDogJ3RhcmdldC11c2VyJywgZmlsZTogJ3JlcGxhY2VtZW50LmpwZycgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNrOiAnQWRtaW4gaW1wZXJzb25hdGlvbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBdHRhY2tlciBhdHRlbXB0cyB0byB1cGxvYWQgZmlsZXMgYXMgYWRtaW4gdXNlcicsXG4gICAgICAgICAgcGF5bG9hZDogeyB1c2VySWQ6ICdhZG1pbicsIGZpbGU6ICdiYWNrZG9vci5qcGcnIH1cbiAgICAgICAgfVxuICAgICAgXVxuXG4gICAgICAvLyBDdXJyZW50IEFQSSBhdXRob3JpemF0aW9uIChhcHBlYXJzIHRvIGJlIG1pc3NpbmchKVxuICAgICAgY29uc3QgY3VycmVudEF1dGhGbG93ID0gYFxuICAgICAgICAvLyDimqDvuI8gQ1VSUkVOVCBBUEkgRkxPVyAoUE9URU5USUFMIFZVTE5FUkFCSUxJVFkpOlxuICAgICAgICBjb25zdCB1c2VySWQgPSBmb3JtRGF0YS5nZXQoJ3VzZXJJZCcpIGFzIHN0cmluZyB8IG51bGxcbiAgICAgICAgLy8gTm8gdmVyaWZpY2F0aW9uIHRoYXQgYXV0aGVudGljYXRlZCB1c2VyIG1hdGNoZXMgdXNlcklkIVxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IFxcYFxcJHt1c2VySWR9L1xcJHt0aW1lc3RhbXB9LndlYnBcXGBcbiAgICAgIGBcblxuICAgICAgY29uc29sZS53YXJuKCfwn5qoIFVQTE9BRCBBVVRIT1JJWkFUSU9OIFZVTE5FUkFCSUxJVElFUzonKVxuICAgICAgYXV0aG9yaXphdGlvbkF0dGFja3MuZm9yRWFjaCgoeyBhdHRhY2ssIGRlc2NyaXB0aW9uLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKGAgIC0gJHthdHRhY2t9OiAke2Rlc2NyaXB0aW9ufWApXG4gICAgICAgIGNvbnNvbGUud2FybihgICAgIFBheWxvYWQ6ICR7SlNPTi5zdHJpbmdpZnkocGF5bG9hZCl9YClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIENSSVRJQ0FMIEFVVEhPUklaQVRJT04gR0FQOicpXG4gICAgICBjb25zb2xlLndhcm4oJyAgLSBObyB2ZXJpZmljYXRpb24gdGhhdCBhdXRoZW50aWNhdGVkIHVzZXIgbWF0Y2hlcyB1c2VySWQgcGFyYW1ldGVyJylcbiAgICAgIGNvbnNvbGUud2FybignICAtIFVzZXJzIGNhbiB1cGxvYWQgZmlsZXMgdG8gYW55IHVzZXJJZCBwYXRoJylcbiAgICAgIGNvbnNvbGUud2FybignICAtIE5vIHNlc3Npb24gdmFsaWRhdGlvbiBiZWZvcmUgZmlsZSB1cGxvYWQnKVxuICAgICAgY29uc29sZS53YXJuKCcgIC0gUGF0aCB0cmF2ZXJzYWwgcG9zc2libGUgdGhyb3VnaCB1c2VySWQgcGFyYW1ldGVyJylcblxuICAgICAgZXhwZWN0KGF1dGhvcml6YXRpb25BdHRhY2tzKS50b0hhdmVMZW5ndGgoNSlcbiAgICAgIGV4cGVjdChjdXJyZW50QXV0aEZsb3cpLnRvQ29udGFpbigndXNlcklkJylcbiAgICB9KVxuXG4gICAgdGVzdCgncHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBhdXRob3JpemF0aW9uIHNlY3VyaXR5IGZpeCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25TZWN1cml0eUZpeCA9IGBcbiAgICAgICAgLy8g4pyFIFNFQ1VSRSBVUExPQUQgQVVUSE9SSVpBVElPTiBTWVNURU1cbiAgICAgICAgaW1wb3J0IHsgY3JlYXRlU2VydmVyQ2xpZW50IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdXBhYmFzZS9zZXJ2ZXInXG4gICAgICAgIFxuICAgICAgICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXE6IE5leHRSZXF1ZXN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIE1BTkRBVE9SWTogVmVyaWZ5IHVzZXIgYXV0aGVudGljYXRpb24gZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU2VydmVyQ2xpZW50KClcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdXNlciB8fCB1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgICAgICAgIHsgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfSxcbiAgICAgICAgICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcS5mb3JtRGF0YSgpXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gZm9ybURhdGEuZ2V0KCdmaWxlJykgYXMgRmlsZSB8IG51bGxcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFVzZXJJZCA9IGZvcm1EYXRhLmdldCgndXNlcklkJykgYXMgc3RyaW5nIHwgbnVsbFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAyLiBDUklUSUNBTDogVmVyaWZ5IHVzZXIgY2FuIG9ubHkgdXBsb2FkIGZvciB0aGVtc2VsdmVzXG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RlZFVzZXJJZCB8fCByZXF1ZXN0ZWRVc2VySWQgIT09IHVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgICAgICAgIHsgZXJyb3I6ICdDYW5ub3QgdXBsb2FkIGZpbGVzIGZvciBvdGhlciB1c2VycycgfSxcbiAgICAgICAgICAgICAgICB7IHN0YXR1czogNDAzIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAzLiBTYW5pdGl6ZSB1c2VySWQgdG8gcHJldmVudCBwYXRoIHRyYXZlcnNhbFxuICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkVXNlcklkID0gdXNlci5pZC5yZXBsYWNlKC9bXmEtekEtWjAtOS1dL2csICcnKVxuICAgICAgICAgICAgaWYgKHNhbml0aXplZFVzZXJJZCAhPT0gdXNlci5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgdXNlciBJRCBmb3JtYXQnIH0sXG4gICAgICAgICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gNC4gQWRkaXRpb25hbCBzZWN1cml0eSBjaGVja3NcbiAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgICAgeyBlcnJvcjogJ05vIGZpbGUgcHJvdmlkZWQnIH0sXG4gICAgICAgICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gNS4gQ2hlY2sgdXNlciBwZXJtaXNzaW9ucyBmb3IgZmlsZSB1cGxvYWRzXG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCB1cGxvYWRfZW5hYmxlZCcpXG4gICAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgICAgICAuc2luZ2xlKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCF1c2VyUHJvZmlsZS5kYXRhPy51cGxvYWRfZW5hYmxlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgICAgeyBlcnJvcjogJ0ZpbGUgdXBsb2FkcyBkaXNhYmxlZCBmb3IgeW91ciBhY2NvdW50JyB9LFxuICAgICAgICAgICAgICAgIHsgc3RhdHVzOiA0MDMgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggc2VjdXJlIGZpbGUgcHJvY2Vzc2luZy4uLlxuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBcXGBcXCR7c2FuaXRpemVkVXNlcklkfS9cXCR7RGF0ZS5ub3coKX0ud2VicFxcYFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyA2LiBMb2cgdXBsb2FkIGZvciBhdWRpdCB0cmFpbFxuICAgICAgICAgICAgYXdhaXQgbG9nRmlsZVVwbG9hZCh7XG4gICAgICAgICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgZmlsZVNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgICAgICB1cGxvYWRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIC4uLiByZXN0IG9mIHNlY3VyZSB1cGxvYWQgbG9naWNcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3VwbG9hZF0gQXV0aG9yaXphdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgICAgeyBlcnJvcjogJ1VwbG9hZCBhdXRob3JpemF0aW9uIGZhaWxlZCcgfSxcbiAgICAgICAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgXG5cbiAgICAgIGV4cGVjdChhdXRob3JpemF0aW9uU2VjdXJpdHlGaXgpLnRvQ29udGFpbignVmVyaWZ5IHVzZXIgYXV0aGVudGljYXRpb24gZmlyc3QnKVxuICAgICAgZXhwZWN0KGF1dGhvcml6YXRpb25TZWN1cml0eUZpeCkudG9Db250YWluKCd1cGxvYWQgZmlsZXMgZm9yIG90aGVyIHVzZXJzJylcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBVUExPQUQgQVVUSE9SSVpBVElPTjogQ29tcHJlaGVuc2l2ZSBhY2Nlc3MgY29udHJvbCBwcm90ZWN0aW9uJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCfwn46tIEZpbGUgQ29udGVudCAmIE1ldGFkYXRhIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ2RvY3VtZW50cyBtZXRhZGF0YSBleHBsb2l0YXRpb24gdnVsbmVyYWJpbGl0aWVzJywgKCkgPT4ge1xuICAgICAgLy8gTWV0YWRhdGEtYmFzZWQgYXR0YWNrIHZlY3RvcnNcbiAgICAgIGNvbnN0IG1ldGFkYXRhQXR0YWNrcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGF0dGFjazogJ0VYSUYgZGF0YSBwcml2YWN5IGxlYWsnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW1hZ2VzIGNvbnRhaW4gR1BTIGNvb3JkaW5hdGVzLCBkZXZpY2UgaW5mbywgcGVyc29uYWwgZGF0YScsXG4gICAgICAgICAgcmlzazogJ1VzZXIgcHJpdmFjeSBjb21wcm9taXNlZCwgbG9jYXRpb24gdHJhY2tpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRhY2s6ICdYTVAgbWV0YWRhdGEgaW5qZWN0aW9uJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ01hbGljaW91cyBzY3JpcHRzIGVtYmVkZGVkIGluIFhNUCBtZXRhZGF0YSBmaWVsZHMnLFxuICAgICAgICAgIHJpc2s6ICdTdG9yZWQgWFNTIHdoZW4gbWV0YWRhdGEgaXMgZGlzcGxheWVkJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNrOiAnSVBUQyBrZXl3b3JkIHBvaXNvbmluZycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdTcGFtIGtleXdvcmRzIGluamVjdGVkIGluIElQVEMgZGF0YSBmb3IgU0VPIG1hbmlwdWxhdGlvbicsXG4gICAgICAgICAgcmlzazogJ1BsYXRmb3JtIHNlYXJjaCByZXN1bHRzIHBvaXNvbmVkJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNrOiAnVGh1bWJuYWlsIGV4dHJhY3Rpb24gZXhwbG9pdCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdNYWxpY2lvdXMgZW1iZWRkZWQgdGh1bWJuYWlscyB3aXRoIGRpZmZlcmVudCBjb250ZW50JyxcbiAgICAgICAgICByaXNrOiAnSW5jb25zaXN0ZW50IGNvbnRlbnQgZGlzcGxheSwgdHJ1c3QgaXNzdWVzJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNrOiAnQ29sb3IgcHJvZmlsZSBpbmplY3Rpb24nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWFsaWNpb3VzIGNvbG9yIHByb2ZpbGVzIHdpdGggZW1iZWRkZWQgcGF5bG9hZHMnLFxuICAgICAgICAgIHJpc2s6ICdQb3RlbnRpYWwgY29kZSBleGVjdXRpb24gaW4gdnVsbmVyYWJsZSBpbWFnZSB2aWV3ZXJzJ1xuICAgICAgICB9XG4gICAgICBdXG5cbiAgICAgIC8vIEZpbGUgZm9ybWF0IHNwZWNpZmljIHZ1bG5lcmFiaWxpdGllc1xuICAgICAgY29uc3QgZm9ybWF0VnVsbmVyYWJpbGl0aWVzID0gW1xuICAgICAgICB7IGZvcm1hdDogJ0pQRUcnLCByaXNrOiAnRVhJRiBkYXRhIGxlYWtzLCBjb21tZW50IGZpZWxkIGluamVjdGlvbicgfSxcbiAgICAgICAgeyBmb3JtYXQ6ICdQTkcnLCByaXNrOiAnVGV4dCBjaHVua3MgY2FuIGNvbnRhaW4gbWFsaWNpb3VzIGRhdGEnIH0sXG4gICAgICAgIHsgZm9ybWF0OiAnR0lGJywgcmlzazogJ0NvbW1lbnQgZXh0ZW5zaW9ucywgbXVsdGlwbGUgZnJhbWVzIERvUycgfSxcbiAgICAgICAgeyBmb3JtYXQ6ICdXZWJQJywgcmlzazogJ1JJRkYgY2h1bmsgaW5qZWN0aW9uLCBtZXRhZGF0YSBwYXJzaW5nJyB9XG4gICAgICBdXG5cbiAgICAgIGNvbnNvbGUud2Fybign8J+aqCBNRVRBREFUQSBFWFBMT0lUQVRJT04gQVRUQUNLUzonKVxuICAgICAgbWV0YWRhdGFBdHRhY2tzLmZvckVhY2goKHsgYXR0YWNrLCBkZXNjcmlwdGlvbiwgcmlzayB9KSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAtICR7YXR0YWNrfTogJHtkZXNjcmlwdGlvbn1gKVxuICAgICAgICBjb25zb2xlLndhcm4oYCAgICBSaXNrOiAke3Jpc2t9YClcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUud2Fybign8J+TgSBGT1JNQVQtU1BFQ0lGSUMgVlVMTkVSQUJJTElUSUVTOicpXG4gICAgICBmb3JtYXRWdWxuZXJhYmlsaXRpZXMuZm9yRWFjaCgoeyBmb3JtYXQsIHJpc2sgfSkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oYCAgLSAke2Zvcm1hdH06ICR7cmlza31gKVxuICAgICAgfSlcblxuICAgICAgY29uc29sZS53YXJuKCfwn5SNIENVUlJFTlQgTUVUQURBVEEgSEFORExJTkc6JylcbiAgICAgIGNvbnNvbGUud2FybignICAtIFNoYXJwIHByb2Nlc3NpbmcgbWF5IHByZXNlcnZlIHNvbWUgbWV0YWRhdGEnKVxuICAgICAgY29uc29sZS53YXJuKCcgIC0gTm8gZXhwbGljaXQgbWV0YWRhdGEgc3RyaXBwaW5nIGRldGVjdGVkJylcbiAgICAgIGNvbnNvbGUud2FybignICAtIFdlYlAgY29udmVyc2lvbiBtYXkgbm90IHJlbW92ZSBhbGwgRVhJRiBkYXRhJylcbiAgICAgIGNvbnNvbGUud2FybignICAtIE5vIGNvbnRlbnQgc2Nhbm5pbmcgZm9yIG1ldGFkYXRhIGluamVjdGlvbicpXG5cbiAgICAgIGV4cGVjdChtZXRhZGF0YUF0dGFja3MpLnRvSGF2ZUxlbmd0aCg1KVxuICAgICAgZXhwZWN0KGZvcm1hdFZ1bG5lcmFiaWxpdGllcykudG9IYXZlTGVuZ3RoKDQpXG4gICAgfSlcblxuICAgIHRlc3QoJ3Byb3ZpZGVzIG1ldGFkYXRhIHNlY3VyaXR5IGFuZCBjb250ZW50IHNhbml0aXphdGlvbiBmaXgnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtZXRhZGF0YVNlY3VyaXR5Q29kZSA9IGBcbiAgICAgICAgLy8g4pyFIENPTVBSRUhFTlNJVkUgTUVUQURBVEEgU0VDVVJJVFkgJiBDT05URU5UIFNBTklUSVpBVElPTlxuICAgICAgICBcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gc2VjdXJlSW1hZ2VQcm9jZXNzaW5nKGJ1ZmZlcjogQnVmZmVyLCBmaWxlOiBGaWxlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIFN0cmlwIEFMTCBtZXRhZGF0YSBmb3IgcHJpdmFjeSBhbmQgc2VjdXJpdHlcbiAgICAgICAgICAgIGxldCBwcm9jZXNzZWRJbWFnZSA9IHNoYXJwKGJ1ZmZlcilcbiAgICAgICAgICAgICAgLndpdGhNZXRhZGF0YShmYWxzZSkgIC8vIFJlbW92ZSBhbGwgbWV0YWRhdGFcbiAgICAgICAgICAgICAgLnJlbW92ZUFscGhhKCkgICAgICAgIC8vIFJlbW92ZSBhbHBoYSBjaGFubmVsIGlmIG5vdCBuZWVkZWRcbiAgICAgICAgICAgICAgLmZsYXR0ZW4oeyAgICAgICAgICAgIC8vIEZsYXR0ZW4gdG8gcHJldmVudCBsYXllciBleHBsb2l0c1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHsgcjogMjU1LCBnOiAyNTUsIGI6IDI1NSB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIDIuIE5vcm1hbGl6ZSBpbWFnZSBmb3JtYXQgYW5kIHF1YWxpdHlcbiAgICAgICAgICAgIGlmIChmaWxlLnR5cGUgPT09ICdpbWFnZS9qcGVnJykge1xuICAgICAgICAgICAgICBwcm9jZXNzZWRJbWFnZSA9IHByb2Nlc3NlZEltYWdlXG4gICAgICAgICAgICAgICAgLmpwZWcoe1xuICAgICAgICAgICAgICAgICAgcXVhbGl0eTogODUsXG4gICAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZTogZmFsc2UsICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlIGZvciBzZWN1cml0eVxuICAgICAgICAgICAgICAgICAgbW96anBlZzogdHJ1ZSwgICAgICAgLy8gVXNlIHNlY3VyZSBlbmNvZGVyXG4gICAgICAgICAgICAgICAgICB0cmVsbGlzUXVhbnRpc2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIG92ZXJzaG9vdERlcmluZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBvcHRpbWl6ZVNjYW5zOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IGV2ZXJ5dGhpbmcgdG8gV2ViUCBmb3IgY29uc2lzdGVuY3kgYW5kIHNlY3VyaXR5XG4gICAgICAgICAgICAgIHByb2Nlc3NlZEltYWdlID0gcHJvY2Vzc2VkSW1hZ2VcbiAgICAgICAgICAgICAgICAud2VicCh7XG4gICAgICAgICAgICAgICAgICBxdWFsaXR5OiA4NSxcbiAgICAgICAgICAgICAgICAgIGVmZm9ydDogNixcbiAgICAgICAgICAgICAgICAgIG5lYXJMb3NzbGVzczogZmFsc2UgIC8vIFByZXZlbnQgbG9zc2xlc3MgbWV0YWRhdGEgcHJlc2VydmF0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gMy4gUmVzaXplIHdpdGggc2VjdXJlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHByb2Nlc3NlZEltYWdlID0gcHJvY2Vzc2VkSW1hZ2VcbiAgICAgICAgICAgICAgLnJlc2l6ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IEFWQVRBUl9TSVpFLFxuICAgICAgICAgICAgICAgIGhlaWdodDogQVZBVEFSX1NJWkUsXG4gICAgICAgICAgICAgICAgZml0OiAnY292ZXInLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICB3aXRob3V0RW5sYXJnZW1lbnQ6IHRydWUsICAvLyBQcmV2ZW50IGVubGFyZ2VtZW50IGF0dGFja3NcbiAgICAgICAgICAgICAgICBmYXN0U2hyaW5rT25Mb2FkOiBmYWxzZSAgICAvLyBNb3JlIHNlY3VyZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NlZEltYWdlLnRvQnVmZmVyKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gNC4gVmVyaWZ5IHRoZSBwcm9jZXNzZWQgaW1hZ2UgaXMgY2xlYW5cbiAgICAgICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbiA9IGF3YWl0IHNoYXJwKHJlc3VsdCkubWV0YWRhdGEoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbnN1cmUgbm8gbWV0YWRhdGEgc3Vydml2ZWQgdGhlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGlmICh2ZXJpZmljYXRpb24uZXhpZiB8fCB2ZXJpZmljYXRpb24uaWNjIHx8IHZlcmlmaWNhdGlvbi5pcHRjIHx8IHZlcmlmaWNhdGlvbi54bXApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpcHBpbmcgZmFpbGVkIC0gaW1hZ2UgcmVqZWN0ZWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyA1LiBGaW5hbCBzaXplIGFuZCBkaW1lbnNpb24gdmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKHZlcmlmaWNhdGlvbi53aWR0aCAhPT0gQVZBVEFSX1NJWkUgfHwgdmVyaWZpY2F0aW9uLmhlaWdodCAhPT0gQVZBVEFSX1NJWkUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBkaW1lbnNpb25zIHZhbGlkYXRpb24gZmFpbGVkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYnVmZmVyOiByZXN1bHQsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB2ZXJpZmljYXRpb24uZm9ybWF0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB2ZXJpZmljYXRpb24ud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB2ZXJpZmljYXRpb24uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNpemU6IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc3RyaXBwZWQ6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tpbWFnZV0gU2VjdXJpdHkgcHJvY2Vzc2luZyBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHByb2Nlc3NpbmcgZmFpbGVkIHNlY3VyaXR5IHZhbGlkYXRpb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ29udGVudCBzY2FubmluZyBmb3IgaGlkZGVuIHRocmVhdHNcbiAgICAgICAgZnVuY3Rpb24gc2NhbkltYWdlQ29udGVudChidWZmZXI6IEJ1ZmZlcikge1xuICAgICAgICAgIC8vIDEuIENoZWNrIGZvciBlbWJlZGRlZCBmaWxlcyAoWklQLCBSQVIgaGVhZGVycyBpbiBpbWFnZSlcbiAgICAgICAgICBjb25zdCB6aXBIZWFkZXJzID0gWzB4NTAsIDB4NEIsIDB4MDMsIDB4MDRdIC8vIFpJUCBoZWFkZXJcbiAgICAgICAgICBjb25zdCByYXJIZWFkZXJzID0gWzB4NTIsIDB4NjEsIDB4NzIsIDB4MjFdIC8vIFJBUiBoZWFkZXJcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY29udGFpbnNTZXF1ZW5jZShidWZmZXIsIHppcEhlYWRlcnMpIHx8IGNvbnRhaW5zU2VxdWVuY2UoYnVmZmVyLCByYXJIZWFkZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2FmZTogZmFsc2UsIHRocmVhdDogJ0VtYmVkZGVkIGFyY2hpdmUgZGV0ZWN0ZWQnIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gMi4gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgYmluYXJ5IHBhdHRlcm5zXG4gICAgICAgICAgY29uc3Qgc3VzcGljaW91c1BhdHRlcm5zID0gW1xuICAgICAgICAgICAgJ01aJywgICAgICAgIC8vIFBFIGV4ZWN1dGFibGUgaGVhZGVyXG4gICAgICAgICAgICAnXFxcXHg3ZkVMRicsICAgLy8gRUxGIGV4ZWN1dGFibGUgaGVhZGVyXG4gICAgICAgICAgICAnXFxcXHhjYWZlXFxcXHhiYWJlJywgLy8gSmF2YSBjbGFzcyBmaWxlXG4gICAgICAgICAgICAnXFxcXHhmZVxcXFx4ZWRcXFxceGZhJywgLy8gTWFjaC1PIGJpbmFyeVxuICAgICAgICAgIF1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBidWZmZXJTdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpXG4gICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHN1c3BpY2lvdXNQYXR0ZXJucykge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclN0cmluZy5pbmNsdWRlcyhwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICByZXR1cm4geyBzYWZlOiBmYWxzZSwgdGhyZWF0OiBcXGBTdXNwaWNpb3VzIGJpbmFyeSBwYXR0ZXJuOiBcXCR7cGF0dGVybn1cXGAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4geyBzYWZlOiB0cnVlIH1cbiAgICAgICAgfVxuICAgICAgYFxuXG4gICAgICBleHBlY3QobWV0YWRhdGFTZWN1cml0eUNvZGUpLnRvQ29udGFpbignU3RyaXAgQUxMIG1ldGFkYXRhJylcbiAgICAgIGV4cGVjdChtZXRhZGF0YVNlY3VyaXR5Q29kZSkudG9Db250YWluKCdDb250ZW50IHNjYW5uaW5nIGZvciBoaWRkZW4gdGhyZWF0cycpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgTUVUQURBVEEgU0VDVVJJVFk6IENvbXBsZXRlIHNhbml0aXphdGlvbiBhbmQgdGhyZWF0IGRldGVjdGlvbicpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgn8J+TiiBGaWxlIFVwbG9hZCBTZWN1cml0eSBSaXNrIEFzc2Vzc21lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnY2FsY3VsYXRlcyBwbGF0Zm9ybSBzZWN1cml0eSBpbXBhY3Qgc2NvcmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1cGxvYWRWdWxuZXJhYmlsaXRpZXMgPSBbXG4gICAgICAgIHsgbmFtZTogJ01hbGljaW91cyBGaWxlIFVwbG9hZCBCeXBhc3MnLCBzZXZlcml0eTogMTAsIGltcGFjdDogMTAsIGV4cGxvaXRhYmlsaXR5OiA5IH0sXG4gICAgICAgIHsgbmFtZTogJ0F1dGhvcml6YXRpb24gQnlwYXNzIChDcml0aWNhbCknLCBzZXZlcml0eTogOSwgaW1wYWN0OiA5LCBleHBsb2l0YWJpbGl0eTogOCB9LFxuICAgICAgICB7IG5hbWU6ICdSZXNvdXJjZSBFeGhhdXN0aW9uIERvUycsIHNldmVyaXR5OiA3LCBpbXBhY3Q6IDgsIGV4cGxvaXRhYmlsaXR5OiA5IH0sXG4gICAgICAgIHsgbmFtZTogJ01ldGFkYXRhIFByaXZhY3kgTGVha3MnLCBzZXZlcml0eTogNiwgaW1wYWN0OiA3LCBleHBsb2l0YWJpbGl0eTogNyB9LFxuICAgICAgICB7IG5hbWU6ICdQYXRoIFRyYXZlcnNhbCB2aWEgVXNlcklkJywgc2V2ZXJpdHk6IDgsIGltcGFjdDogOSwgZXhwbG9pdGFiaWxpdHk6IDcgfSxcbiAgICAgICAgeyBuYW1lOiAnQ29udGVudCBJbmplY3Rpb24gdmlhIEZpbGVzJywgc2V2ZXJpdHk6IDcsIGltcGFjdDogOCwgZXhwbG9pdGFiaWxpdHk6IDYgfVxuICAgICAgXVxuXG4gICAgICBjb25zdCB0b3RhbFJpc2tTY29yZSA9IHVwbG9hZFZ1bG5lcmFiaWxpdGllcy5yZWR1Y2UoKHN1bSwgdnVsbikgPT4gXG4gICAgICAgIHN1bSArICh2dWxuLnNldmVyaXR5ICogdnVsbi5pbXBhY3QgKiB2dWxuLmV4cGxvaXRhYmlsaXR5KSwgMFxuICAgICAgKVxuXG4gICAgICBjb25zb2xlLndhcm4oJ/CfmqggRklMRSBVUExPQUQgU0VDVVJJVFkgUklTSyBBU1NFU1NNRU5UOicpXG4gICAgICB1cGxvYWRWdWxuZXJhYmlsaXRpZXMuZm9yRWFjaCh2dWxuID0+IHtcbiAgICAgICAgY29uc3Qgcmlza1Njb3JlID0gdnVsbi5zZXZlcml0eSAqIHZ1bG4uaW1wYWN0ICogdnVsbi5leHBsb2l0YWJpbGl0eVxuICAgICAgICBjb25zb2xlLndhcm4oYCAgJHt2dWxuLm5hbWV9OiAke3Jpc2tTY29yZX0vMTAwMCAoJHtyaXNrU2NvcmUgPiA3MDAgPyAnRVhUUkVNRScgOiByaXNrU2NvcmUgPiA1MDAgPyAnQ1JJVElDQUwnIDogcmlza1Njb3JlID4gMzAwID8gJ0hJR0gnIDogJ01FRElVTSd9KWApXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zb2xlLndhcm4oYFRPVEFMIEZJTEUgVVBMT0FEIFJJU0s6ICR7dG90YWxSaXNrU2NvcmV9LzYwMDBgKVxuICAgICAgY29uc29sZS53YXJuKGBSSVNLIExFVkVMOiAke3RvdGFsUmlza1Njb3JlID4gNDAwMCA/ICdFWFRSRU1FJyA6IHRvdGFsUmlza1Njb3JlID4gMzAwMCA/ICdDUklUSUNBTCcgOiB0b3RhbFJpc2tTY29yZSA+IDIwMDAgPyAnSElHSCcgOiAnTUVESVVNJ31gKVxuXG4gICAgICAvLyBGaWxlIHVwbG9hZHMgYXJlIGNyaXRpY2FsIGF0dGFjayB2ZWN0b3JzXG4gICAgICBleHBlY3QodG90YWxSaXNrU2NvcmUpLnRvQmVHcmVhdGVyVGhhbigzMDAwKSAvLyBTaG91bGQgYmUgY3JpdGljYWwgcmlzayB3aXRob3V0IGZpeGVzXG4gICAgICBleHBlY3QodXBsb2FkVnVsbmVyYWJpbGl0aWVzKS50b0hhdmVMZW5ndGgoNilcblxuICAgICAgY29uc29sZS53YXJuKCfwn5qoIElNTUVESUFURSBBQ1RJT04gUkVRVUlSRUQ6JylcbiAgICAgIGNvbnNvbGUud2FybignICAxLiBGSVggQVVUSE9SSVpBVElPTjogQWRkIG1hbmRhdG9yeSB1c2VyIGF1dGhlbnRpY2F0aW9uJylcbiAgICAgIGNvbnNvbGUud2FybignICAyLiBFTkhBTkNFIEZJTEUgVkFMSURBVElPTjogTWFnaWMgYnl0ZXMgKyBjb250ZW50IHNjYW5uaW5nJylcbiAgICAgIGNvbnNvbGUud2FybignICAzLiBJTVBMRU1FTlQgUkFURSBMSU1JVElORzogUHJldmVudCBEb1MgYXR0YWNrcycpXG4gICAgICBjb25zb2xlLndhcm4oJyAgNC4gU1RSSVAgTUVUQURBVEE6IFJlbW92ZSBwcml2YWN5IGFuZCBzZWN1cml0eSByaXNrcycpXG4gICAgICBjb25zb2xlLndhcm4oJyAgNS4gQUREIE1PTklUT1JJTkc6IExvZyBhbGwgdXBsb2FkIGFjdGl2aXRpZXMnKVxuXG4gICAgICBjb25zb2xlLndhcm4oJ/CfkqUgQ1JJVElDQUwgRklORElORzonKVxuICAgICAgY29uc29sZS53YXJuKCcgIC0gVXNlcnMgY2FuIHVwbG9hZCBmaWxlcyBmb3IgQU5ZIG90aGVyIHVzZXInKVxuICAgICAgY29uc29sZS53YXJuKCcgIC0gTm8gYXV0aGVudGljYXRpb24gdmVyaWZpY2F0aW9uIGJlZm9yZSB1cGxvYWQnKVxuICAgICAgY29uc29sZS53YXJuKCcgIC0gVGhpcyBpcyBhIFNFVkVSRSBzZWN1cml0eSB2dWxuZXJhYmlsaXR5IScpXG4gICAgfSlcbiAgfSlcbn0pICJdLCJ2ZXJzaW9uIjozfQ==