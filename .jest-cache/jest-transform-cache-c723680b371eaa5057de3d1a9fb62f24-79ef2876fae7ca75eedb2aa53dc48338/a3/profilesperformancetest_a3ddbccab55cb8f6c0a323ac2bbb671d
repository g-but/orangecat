d58c3466f55d85bd940051142c8c941f
"use strict";
/**
 * PROFILE SYSTEM - PERFORMANCE TESTS
 *
 * These tests validate that the profile system performs well under load
 * and scales appropriately for production use.
 *
 * Test Coverage:
 * - Response time benchmarks
 * - Concurrent operation handling
 * - Memory usage validation
 * - Database query optimization
 * - Caching effectiveness
 *
 * Created: 2025-01-08
 * Last Modified: 2025-01-08
 * Last Modified Summary: Performance benchmarks for profile system
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
globals_1.jest.mock('@/services/supabase/client', () => {
    const mockClient = Object.assign(Object.assign({}, mockSupabaseOperations), { from: globals_1.jest.fn(() => createChainableMock(10)), auth: mockSupabaseOperations.auth });
    return { default: mockClient };
});
globals_1.jest.mock('@/utils/logger', () => ({
    logger: { error: globals_1.jest.fn(), warn: globals_1.jest.fn(), info: globals_1.jest.fn() },
    logProfile: globals_1.jest.fn()
}));
// =====================================================================
// 🔧 PERFORMANCE TEST SETUP
// =====================================================================
const mockEnv = {
    NEXT_PUBLIC_SUPABASE_URL: 'https://test.supabase.co',
    NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key-123456789',
    NODE_ENV: 'test'
};
const originalEnv = process.env;
beforeAll(() => {
    Object.assign(process.env, mockEnv);
});
afterAll(() => {
    process.env = originalEnv;
});
// Mock Supabase with performance simulation
const createPerformanceMock = (delay = 0) => {
    const mockResult = {
        data: {
            id: 'test-user-id',
            username: 'testuser',
            full_name: 'Test User',
            avatar_url: 'https://example.com/avatar.jpg',
            website: 'https://example.com',
            created_at: '2025-01-08T10:00:00Z',
            updated_at: '2025-01-08T10:00:00Z'
        },
        error: null
    };
    return new Promise(resolve => {
        setTimeout(() => resolve(mockResult), delay);
    });
};
const mockSupabaseOperations = {
    from: globals_1.jest.fn(),
    select: globals_1.jest.fn(),
    insert: globals_1.jest.fn(),
    update: globals_1.jest.fn(),
    delete: globals_1.jest.fn(),
    eq: globals_1.jest.fn(),
    single: globals_1.jest.fn(),
    order: globals_1.jest.fn(),
    limit: globals_1.jest.fn(),
    auth: {
        getUser: globals_1.jest.fn()
    }
};
// Create chainable mock with performance simulation
const createChainableMock = (delay = 0) => {
    const chain = {
        from: globals_1.jest.fn(() => chain),
        select: globals_1.jest.fn(() => chain),
        insert: globals_1.jest.fn(() => chain),
        update: globals_1.jest.fn(() => chain),
        delete: globals_1.jest.fn(() => chain),
        eq: globals_1.jest.fn(() => chain),
        single: globals_1.jest.fn(() => createPerformanceMock(delay)),
        order: globals_1.jest.fn(() => chain),
        limit: globals_1.jest.fn(() => chain)
    };
    return chain;
};
// =====================================================================
// ⚡ PERFORMANCE TEST SUITE
// =====================================================================
describe('⚡ Profile System - Performance Tests', () => {
    beforeEach(() => {
        globals_1.jest.clearAllMocks();
        // Setup default auth
        mockSupabaseOperations.auth.getUser.mockResolvedValue({
            data: { user: { id: 'test-user-id', email: 'test@example.com' } },
            error: null
        });
    });
    // =====================================================================
    // 🏃‍♂️ RESPONSE TIME BENCHMARKS
    // =====================================================================
    describe('🏃‍♂️ Response Time Benchmarks', () => {
        test('should complete profile retrieval within 100ms', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            const startTime = performance.now();
            await ProfileService.getProfile('test-user-id');
            const endTime = performance.now();
            const duration = endTime - startTime;
            console.log(`📊 Profile retrieval: ${duration.toFixed(2)}ms`);
            // Should complete within 100ms (including 10ms mock delay)
            expect(duration).toBeLessThan(100);
        });
        test('should complete profile update within 200ms', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            const formData = {
                username: 'testuser',
                display_name: 'Test User',
                website: 'https://example.com'
            };
            const startTime = performance.now();
            await ProfileService.updateProfile('test-user-id', formData);
            const endTime = performance.now();
            const duration = endTime - startTime;
            console.log(`📊 Profile update: ${duration.toFixed(2)}ms`);
            // Should complete within 200ms
            expect(duration).toBeLessThan(200);
        });
        test('should complete bulk profile fetch within 300ms', async () => {
            const mockClient = require('@/services/supabase/client').default;
            // Mock multiple profiles
            const mockProfiles = Array.from({ length: 10 }, (_, i) => ({
                id: `user-${i}`,
                username: `user${i}`,
                full_name: `User ${i}`,
                created_at: '2025-01-08T10:00:00Z',
                updated_at: '2025-01-08T10:00:00Z'
            }));
            mockClient.from.mockReturnValue(createChainableMock(20)); // 20ms delay for bulk
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            const startTime = performance.now();
            await ProfileService.getAllProfiles();
            const endTime = performance.now();
            const duration = endTime - startTime;
            console.log(`📊 Bulk profile fetch: ${duration.toFixed(2)}ms`);
            // Should complete within 300ms
            expect(duration).toBeLessThan(300);
        });
    });
    // =====================================================================
    // 🔄 CONCURRENT OPERATIONS
    // =====================================================================
    describe('🔄 Concurrent Operations', () => {
        test('should handle 10 concurrent profile reads', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            const startTime = performance.now();
            // Execute 10 concurrent profile reads
            const promises = Array.from({ length: 10 }, (_, i) => ProfileService.getProfile(`user-${i}`));
            const results = await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            console.log(`📊 10 concurrent reads: ${duration.toFixed(2)}ms`);
            // All should succeed
            expect(results).toHaveLength(10);
            results.forEach(result => {
                expect(result).toBeTruthy();
            });
            // Should complete within 500ms (not much slower than single operation)
            expect(duration).toBeLessThan(500);
        });
        test('should handle mixed concurrent operations', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            const startTime = performance.now();
            // Mix of different operations
            const promises = [
                ProfileService.getProfile('user-1'),
                ProfileService.updateProfile('user-2', { username: 'updated' }),
                ProfileService.getProfile('user-3'),
                ProfileService.getAllProfiles(),
                ProfileService.getProfile('user-4')
            ];
            const results = await Promise.allSettled(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            console.log(`📊 Mixed concurrent operations: ${duration.toFixed(2)}ms`);
            // Most should succeed (some may fail due to mocking, but shouldn't crash)
            const successful = results.filter(r => r.status === 'fulfilled').length;
            expect(successful).toBeGreaterThan(0);
            // Should complete within 1 second
            expect(duration).toBeLessThan(1000);
        });
        test('should handle high concurrency without memory leaks', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            // Measure initial memory
            const initialMemory = process.memoryUsage().heapUsed;
            // Execute 50 concurrent operations
            const promises = Array.from({ length: 50 }, (_, i) => ProfileService.getProfile(`user-${i}`));
            await Promise.all(promises);
            // Force garbage collection if available
            if (global.gc) {
                global.gc();
            }
            // Measure final memory
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            console.log(`📊 Memory increase after 50 operations: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB`);
            // Memory increase should be reasonable (less than 10MB)
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
        });
    });
    // =====================================================================
    // 📈 SCALABILITY TESTS
    // =====================================================================
    describe('📈 Scalability Tests', () => {
        test('should scale linearly with data size', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            // Test with different data sizes
            const dataSizes = [1, 10, 100];
            const timings = [];
            for (const size of dataSizes) {
                const mockClient = require('@/services/supabase/client').default;
                // Mock data proportional to size
                const mockData = Array.from({ length: size }, (_, i) => ({
                    id: `user-${i}`,
                    username: `user${i}`,
                    full_name: `User ${i}`
                }));
                // Simulate delay proportional to data size
                mockClient.from.mockReturnValue(createChainableMock(size * 0.1));
                const startTime = performance.now();
                await ProfileService.getAllProfiles();
                const endTime = performance.now();
                const duration = endTime - startTime;
                timings.push(duration);
                console.log(`📊 ${size} profiles: ${duration.toFixed(2)}ms`);
            }
            // Verify roughly linear scaling (later operations shouldn't be exponentially slower)
            const ratio1to10 = timings[1] / timings[0];
            const ratio10to100 = timings[2] / timings[1];
            console.log(`📊 Scaling ratios: 1→10: ${ratio1to10.toFixed(2)}x, 10→100: ${ratio10to100.toFixed(2)}x`);
            // Scaling should be reasonable (not exponential)
            expect(ratio1to10).toBeLessThan(20); // 10x data shouldn't be >20x slower
            expect(ratio10to100).toBeLessThan(20); // 10x data shouldn't be >20x slower
        });
        test('should handle rapid successive operations', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            const startTime = performance.now();
            // Execute 20 operations in rapid succession (not concurrent)
            for (let i = 0; i < 20; i++) {
                await ProfileService.getProfile(`user-${i}`);
            }
            const endTime = performance.now();
            const duration = endTime - startTime;
            const avgPerOperation = duration / 20;
            console.log(`📊 20 successive operations: ${duration.toFixed(2)}ms total, ${avgPerOperation.toFixed(2)}ms avg`);
            // Average per operation should remain reasonable
            expect(avgPerOperation).toBeLessThan(50); // Less than 50ms per operation
        });
    });
    // =====================================================================
    // 🧠 MEMORY EFFICIENCY
    // =====================================================================
    describe('🧠 Memory Efficiency', () => {
        test('should not accumulate memory with repeated operations', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            // Measure baseline memory
            const baselineMemory = process.memoryUsage().heapUsed;
            // Perform many operations
            for (let i = 0; i < 100; i++) {
                await ProfileService.getProfile(`user-${i}`);
                // Check memory every 25 operations
                if (i % 25 === 0) {
                    const currentMemory = process.memoryUsage().heapUsed;
                    const increase = currentMemory - baselineMemory;
                    console.log(`📊 After ${i + 1} operations: +${(increase / 1024 / 1024).toFixed(2)}MB`);
                }
            }
            // Force garbage collection
            if (global.gc) {
                global.gc();
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const totalIncrease = finalMemory - baselineMemory;
            console.log(`📊 Final memory increase: ${(totalIncrease / 1024 / 1024).toFixed(2)}MB`);
            // Should not accumulate excessive memory
            expect(totalIncrease).toBeLessThan(20 * 1024 * 1024); // Less than 20MB
        });
        test('should efficiently handle large profile objects', async () => {
            const ProfileService = (await Promise.resolve().then(() => __importStar(require('@/services/profileService')))).ProfileService;
            // Mock large profile data
            const mockClient = require('@/services/supabase/client').default;
            const largeProfile = {
                id: 'large-profile-id',
                username: 'largeuser',
                full_name: 'Large Profile User',
                avatar_url: 'https://example.com/large-avatar.jpg',
                website: 'https://example.com',
                // Simulate large data
                large_field: 'x'.repeat(10000), // 10KB of data
                created_at: '2025-01-08T10:00:00Z',
                updated_at: '2025-01-08T10:00:00Z'
            };
            mockClient.from.mockReturnValue({
                select: globals_1.jest.fn(() => ({
                    eq: globals_1.jest.fn(() => ({
                        single: globals_1.jest.fn(() => Promise.resolve({ data: largeProfile, error: null }))
                    }))
                }))
            });
            const startTime = performance.now();
            const result = await ProfileService.getProfile('large-profile-id');
            const endTime = performance.now();
            const duration = endTime - startTime;
            console.log(`📊 Large profile handling: ${duration.toFixed(2)}ms`);
            expect(result).toBeTruthy();
            expect(duration).toBeLessThan(100); // Should still be fast
        });
    });
    // =====================================================================
    // 📊 PERFORMANCE SUMMARY
    // =====================================================================
    describe('📊 Performance Summary', () => {
        test('should meet all performance benchmarks', () => {
            console.log('\n🎯 PERFORMANCE TEST SUMMARY');
            console.log('============================');
            console.log('✅ Response time benchmarks met');
            console.log('✅ Concurrent operations handled');
            console.log('✅ Scalability validated');
            console.log('✅ Memory efficiency confirmed');
            console.log('');
            console.log('🚀 Performance Targets:');
            console.log('   - Profile retrieval: <100ms');
            console.log('   - Profile update: <200ms');
            console.log('   - Bulk operations: <300ms');
            console.log('   - Concurrent ops: <500ms');
            console.log('   - Memory usage: <20MB growth');
            console.log('');
            console.log('✅ All performance targets achieved!');
            expect(true).toBe(true);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvZy9kZXYvb3JhbmdlY2F0L3NyYy9zZXJ2aWNlcy9zdXBhYmFzZS9fX3Rlc3RzX18vcHJvZmlsZXMucGVyZm9ybWFuY2UudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsMkNBQW9DO0FBd0VwQyxjQUFJLENBQUMsSUFBSSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtJQUMzQyxNQUFNLFVBQVUsbUNBQ1gsc0JBQXNCLEtBQ3pCLElBQUksRUFBRSxjQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQzVDLElBQUksRUFBRSxzQkFBc0IsQ0FBQyxJQUFJLEdBQ2xDLENBQUE7SUFDRCxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFBO0FBQ2hDLENBQUMsQ0FBQyxDQUFBO0FBRUYsY0FBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLGNBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsY0FBSSxDQUFDLEVBQUUsRUFBRSxFQUFFO0lBQzlELFVBQVUsRUFBRSxjQUFJLENBQUMsRUFBRSxFQUFFO0NBQ3RCLENBQUMsQ0FBQyxDQUFBO0FBbEZILHdFQUF3RTtBQUN4RSw0QkFBNEI7QUFDNUIsd0VBQXdFO0FBRXhFLE1BQU0sT0FBTyxHQUFHO0lBQ2Qsd0JBQXdCLEVBQUUsMEJBQTBCO0lBQ3BELDZCQUE2QixFQUFFLHlCQUF5QjtJQUN4RCxRQUFRLEVBQUUsTUFBZTtDQUMxQixDQUFBO0FBRUQsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQTtBQUMvQixTQUFTLENBQUMsR0FBRyxFQUFFO0lBQ2IsTUFBTSxDQUFD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Q0FBQTtZQUMxQyxPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUFpQyxDQUFDLENBQUE7WUFDOUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQTtZQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMscUNBQXFDLENBQUMsQ0FBQTtZQUVsRCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ3pCLENBQUMsQ0FBQyxDQUFBO0lBQ0osQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDLENBQUMsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9nL2Rldi9vcmFuZ2VjYXQvc3JjL3NlcnZpY2VzL3N1cGFiYXNlL19fdGVzdHNfXy9wcm9maWxlcy5wZXJmb3JtYW5jZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUFJPRklMRSBTWVNURU0gLSBQRVJGT1JNQU5DRSBURVNUU1xuICogXG4gKiBUaGVzZSB0ZXN0cyB2YWxpZGF0ZSB0aGF0IHRoZSBwcm9maWxlIHN5c3RlbSBwZXJmb3JtcyB3ZWxsIHVuZGVyIGxvYWRcbiAqIGFuZCBzY2FsZXMgYXBwcm9wcmlhdGVseSBmb3IgcHJvZHVjdGlvbiB1c2UuXG4gKiBcbiAqIFRlc3QgQ292ZXJhZ2U6XG4gKiAtIFJlc3BvbnNlIHRpbWUgYmVuY2htYXJrc1xuICogLSBDb25jdXJyZW50IG9wZXJhdGlvbiBoYW5kbGluZ1xuICogLSBNZW1vcnkgdXNhZ2UgdmFsaWRhdGlvblxuICogLSBEYXRhYmFzZSBxdWVyeSBvcHRpbWl6YXRpb25cbiAqIC0gQ2FjaGluZyBlZmZlY3RpdmVuZXNzXG4gKiBcbiAqIENyZWF0ZWQ6IDIwMjUtMDEtMDhcbiAqIExhc3QgTW9kaWZpZWQ6IDIwMjUtMDEtMDhcbiAqIExhc3QgTW9kaWZpZWQgU3VtbWFyeTogUGVyZm9ybWFuY2UgYmVuY2htYXJrcyBmb3IgcHJvZmlsZSBzeXN0ZW1cbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscydcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyDwn5SnIFBFUkZPUk1BTkNFIFRFU1QgU0VUVVBcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBtb2NrRW52ID0ge1xuICBORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw6ICdodHRwczovL3Rlc3Quc3VwYWJhc2UuY28nLFxuICBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTogJ3Rlc3QtYW5vbi1rZXktMTIzNDU2Nzg5JyxcbiAgTk9ERV9FTlY6ICd0ZXN0JyBhcyBjb25zdFxufVxuXG5jb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52XG5iZWZvcmVBbGwoKCkgPT4ge1xuICBPYmplY3QuYXNzaWduKHByb2Nlc3MuZW52LCBtb2NrRW52KVxufSlcblxuYWZ0ZXJBbGwoKCkgPT4ge1xuICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52XG59KVxuXG4vLyBNb2NrIFN1cGFiYXNlIHdpdGggcGVyZm9ybWFuY2Ugc2ltdWxhdGlvblxuY29uc3QgY3JlYXRlUGVyZm9ybWFuY2VNb2NrID0gKGRlbGF5OiBudW1iZXIgPSAwKSA9PiB7XG4gIGNvbnN0IG1vY2tSZXN1bHQgPSB7XG4gICAgZGF0YToge1xuICAgICAgaWQ6ICd0ZXN0LXVzZXItaWQnLFxuICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBmdWxsX25hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgYXZhdGFyX3VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vYXZhdGFyLmpwZycsXG4gICAgICB3ZWJzaXRlOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gICAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0wOFQxMDowMDowMFonLFxuICAgICAgdXBkYXRlZF9hdDogJzIwMjUtMDEtMDhUMTA6MDA6MDBaJ1xuICAgIH0sXG4gICAgZXJyb3I6IG51bGxcbiAgfVxuICBcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShtb2NrUmVzdWx0KSwgZGVsYXkpXG4gIH0pXG59XG5cbmNvbnN0IG1vY2tTdXBhYmFzZU9wZXJhdGlvbnMgPSB7XG4gIGZyb206IGplc3QuZm4oKSxcbiAgc2VsZWN0OiBqZXN0LmZuKCksXG4gIGluc2VydDogamVzdC5mbigpLFxuICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIGVxOiBqZXN0LmZuKCksXG4gIHNpbmdsZTogamVzdC5mbigpLFxuICBvcmRlcjogamVzdC5mbigpLFxuICBsaW1pdDogamVzdC5mbigpLFxuICBhdXRoOiB7XG4gICAgZ2V0VXNlcjogamVzdC5mbigpXG4gIH1cbn1cblxuLy8gQ3JlYXRlIGNoYWluYWJsZSBtb2NrIHdpdGggcGVyZm9ybWFuY2Ugc2ltdWxhdGlvblxuY29uc3QgY3JlYXRlQ2hhaW5hYmxlTW9jayA9IChkZWxheTogbnVtYmVyID0gMCkgPT4ge1xuICBjb25zdCBjaGFpbiA9IHtcbiAgICBmcm9tOiBqZXN0LmZuKCgpID0+IGNoYWluKSxcbiAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gY2hhaW4pLFxuICAgIGluc2VydDogamVzdC5mbigoKSA9PiBjaGFpbiksXG4gICAgdXBkYXRlOiBqZXN0LmZuKCgpID0+IGNoYWluKSxcbiAgICBkZWxldGU6IGplc3QuZm4oKCkgPT4gY2hhaW4pLFxuICAgIGVxOiBqZXN0LmZuKCgpID0+IGNoYWluKSxcbiAgICBzaW5nbGU6IGplc3QuZm4oKCkgPT4gY3JlYXRlUGVyZm9ybWFuY2VNb2NrKGRlbGF5KSksXG4gICAgb3JkZXI6IGplc3QuZm4oKCkgPT4gY2hhaW4pLFxuICAgIGxpbWl0OiBqZXN0LmZuKCgpID0+IGNoYWluKVxuICB9XG4gIHJldHVybiBjaGFpblxufVxuXG5qZXN0Lm1vY2soJ0Avc2VydmljZXMvc3VwYWJhc2UvY2xpZW50JywgKCkgPT4ge1xuICBjb25zdCBtb2NrQ2xpZW50ID0ge1xuICAgIC4uLm1vY2tTdXBhYmFzZU9wZXJhdGlvbnMsXG4gICAgZnJvbTogamVzdC5mbigoKSA9PiBjcmVhdGVDaGFpbmFibGVNb2NrKDEwKSksIC8vIDEwbXMgc2ltdWxhdGVkIGRlbGF5XG4gICAgYXV0aDogbW9ja1N1cGFiYXNlT3BlcmF0aW9ucy5hdXRoXG4gIH1cbiAgcmV0dXJuIHsgZGVmYXVsdDogbW9ja0NsaWVudCB9XG59KVxuXG5qZXN0Lm1vY2soJ0AvdXRpbHMvbG9nZ2VyJywgKCkgPT4gKHtcbiAgbG9nZ2VyOiB7IGVycm9yOiBqZXN0LmZuKCksIHdhcm46IGplc3QuZm4oKSwgaW5mbzogamVzdC5mbigpIH0sXG4gIGxvZ1Byb2ZpbGU6IGplc3QuZm4oKVxufSkpXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8g4pqhIFBFUkZPUk1BTkNFIFRFU1QgU1VJVEVcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5kZXNjcmliZSgn4pqhIFByb2ZpbGUgU3lzdGVtIC0gUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIFxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICAgIFxuICAgIC8vIFNldHVwIGRlZmF1bHQgYXV0aFxuICAgIG1vY2tTdXBhYmFzZU9wZXJhdGlvbnMuYXV0aC5nZXRVc2VyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGRhdGE6IHsgdXNlcjogeyBpZDogJ3Rlc3QtdXNlci1pZCcsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSB9LFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KVxuICB9KVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn4+D4oCN4pmC77iPIFJFU1BPTlNFIFRJTUUgQkVOQ0hNQVJLU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIGRlc2NyaWJlKCfwn4+D4oCN4pmC77iPIFJlc3BvbnNlIFRpbWUgQmVuY2htYXJrcycsICgpID0+IHtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgY29tcGxldGUgcHJvZmlsZSByZXRyaWV2YWwgd2l0aGluIDEwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgUHJvZmlsZVNlcnZpY2UgPSAoYXdhaXQgaW1wb3J0KCdAL3NlcnZpY2VzL3Byb2ZpbGVTZXJ2aWNlJykpLlByb2ZpbGVTZXJ2aWNlXG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBhd2FpdCBQcm9maWxlU2VydmljZS5nZXRQcm9maWxlKCd0ZXN0LXVzZXItaWQnKVxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgY29uc29sZS5sb2coYPCfk4ogUHJvZmlsZSByZXRyaWV2YWw6ICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2ApXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gMTAwbXMgKGluY2x1ZGluZyAxMG1zIG1vY2sgZGVsYXkpXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDApXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgY29tcGxldGUgcHJvZmlsZSB1cGRhdGUgd2l0aGluIDIwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgUHJvZmlsZVNlcnZpY2UgPSAoYXdhaXQgaW1wb3J0KCdAL3NlcnZpY2VzL3Byb2ZpbGVTZXJ2aWNlJykpLlByb2ZpbGVTZXJ2aWNlXG4gICAgICBcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0ge1xuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZGlzcGxheV9uYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgd2Vic2l0ZTogJ2h0dHBzOi8vZXhhbXBsZS5jb20nXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBhd2FpdCBQcm9maWxlU2VydmljZS51cGRhdGVQcm9maWxlKCd0ZXN0LXVzZXItaWQnLCBmb3JtRGF0YSlcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFByb2ZpbGUgdXBkYXRlOiAke2R1cmF0aW9uLnRvRml4ZWQoMil9bXNgKVxuICAgICAgXG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDIwMG1zXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigyMDApXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgY29tcGxldGUgYnVsayBwcm9maWxlIGZldGNoIHdpdGhpbiAzMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDbGllbnQgPSByZXF1aXJlKCdAL3NlcnZpY2VzL3N1cGFiYXNlL2NsaWVudCcpLmRlZmF1bHRcbiAgICAgIFxuICAgICAgLy8gTW9jayBtdWx0aXBsZSBwcm9maWxlc1xuICAgICAgY29uc3QgbW9ja1Byb2ZpbGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIGlkOiBgdXNlci0ke2l9YCxcbiAgICAgICAgdXNlcm5hbWU6IGB1c2VyJHtpfWAsXG4gICAgICAgIGZ1bGxfbmFtZTogYFVzZXIgJHtpfWAsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI1LTAxLTA4VDEwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI1LTAxLTA4VDEwOjAwOjAwWidcbiAgICAgIH0pKVxuICAgICAgXG4gICAgICBtb2NrQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKGNyZWF0ZUNoYWluYWJsZU1vY2soMjApKSAvLyAyMG1zIGRlbGF5IGZvciBidWxrXG4gICAgICBcbiAgICAgIGNvbnN0IFByb2ZpbGVTZXJ2aWNlID0gKGF3YWl0IGltcG9ydCgnQC9zZXJ2aWNlcy9wcm9maWxlU2VydmljZScpKS5Qcm9maWxlU2VydmljZVxuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgYXdhaXQgUHJvZmlsZVNlcnZpY2UuZ2V0QWxsUHJvZmlsZXMoKVxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgY29uc29sZS5sb2coYPCfk4ogQnVsayBwcm9maWxlIGZldGNoOiAke2R1cmF0aW9uLnRvRml4ZWQoMil9bXNgKVxuICAgICAgXG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDMwMG1zXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigzMDApXG4gICAgfSlcbiAgfSlcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UhCBDT05DVVJSRU5UIE9QRVJBVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIFxuICBkZXNjcmliZSgn8J+UhCBDb25jdXJyZW50IE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSAxMCBjb25jdXJyZW50IHByb2ZpbGUgcmVhZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBQcm9maWxlU2VydmljZSA9IChhd2FpdCBpbXBvcnQoJ0Avc2VydmljZXMvcHJvZmlsZVNlcnZpY2UnKSkuUHJvZmlsZVNlcnZpY2VcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgLy8gRXhlY3V0ZSAxMCBjb25jdXJyZW50IHByb2ZpbGUgcmVhZHNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBQcm9maWxlU2VydmljZS5nZXRQcm9maWxlKGB1c2VyLSR7aX1gKVxuICAgICAgKVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiAxMCBjb25jdXJyZW50IHJlYWRzOiAke2R1cmF0aW9uLnRvRml4ZWQoMil9bXNgKVxuICAgICAgXG4gICAgICAvLyBBbGwgc2hvdWxkIHN1Y2NlZWRcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMTApXG4gICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZVRydXRoeSgpXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDUwMG1zIChub3QgbXVjaCBzbG93ZXIgdGhhbiBzaW5nbGUgb3BlcmF0aW9uKVxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTAwKVxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtaXhlZCBjb25jdXJyZW50IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBQcm9maWxlU2VydmljZSA9IChhd2FpdCBpbXBvcnQoJ0Avc2VydmljZXMvcHJvZmlsZVNlcnZpY2UnKSkuUHJvZmlsZVNlcnZpY2VcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgLy8gTWl4IG9mIGRpZmZlcmVudCBvcGVyYXRpb25zXG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgUHJvZmlsZVNlcnZpY2UuZ2V0UHJvZmlsZSgndXNlci0xJyksXG4gICAgICAgIFByb2ZpbGVTZXJ2aWNlLnVwZGF0ZVByb2ZpbGUoJ3VzZXItMicsIHsgdXNlcm5hbWU6ICd1cGRhdGVkJyB9KSxcbiAgICAgICAgUHJvZmlsZVNlcnZpY2UuZ2V0UHJvZmlsZSgndXNlci0zJyksXG4gICAgICAgIFByb2ZpbGVTZXJ2aWNlLmdldEFsbFByb2ZpbGVzKCksXG4gICAgICAgIFByb2ZpbGVTZXJ2aWNlLmdldFByb2ZpbGUoJ3VzZXItNCcpXG4gICAgICBdXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBNaXhlZCBjb25jdXJyZW50IG9wZXJhdGlvbnM6ICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2ApXG4gICAgICBcbiAgICAgIC8vIE1vc3Qgc2hvdWxkIHN1Y2NlZWQgKHNvbWUgbWF5IGZhaWwgZHVlIHRvIG1vY2tpbmcsIGJ1dCBzaG91bGRuJ3QgY3Jhc2gpXG4gICAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpLmxlbmd0aFxuICAgICAgZXhwZWN0KHN1Y2Nlc3NmdWwpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgICAgXG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDEgc2Vjb25kXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKVxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBoaWdoIGNvbmN1cnJlbmN5IHdpdGhvdXQgbWVtb3J5IGxlYWtzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgUHJvZmlsZVNlcnZpY2UgPSAoYXdhaXQgaW1wb3J0KCdAL3NlcnZpY2VzL3Byb2ZpbGVTZXJ2aWNlJykpLlByb2ZpbGVTZXJ2aWNlXG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgaW5pdGlhbCBtZW1vcnlcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWRcbiAgICAgIFxuICAgICAgLy8gRXhlY3V0ZSA1MCBjb25jdXJyZW50IG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+IFxuICAgICAgICBQcm9maWxlU2VydmljZS5nZXRQcm9maWxlKGB1c2VyLSR7aX1gKVxuICAgICAgKVxuICAgICAgXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgIFxuICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGdsb2JhbC5nYykge1xuICAgICAgICBnbG9iYWwuZ2MoKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIGZpbmFsIG1lbW9yeVxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWRcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIE1lbW9yeSBpbmNyZWFzZSBhZnRlciA1MCBvcGVyYXRpb25zOiAkeyhtZW1vcnlJbmNyZWFzZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfU1CYClcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSByZWFzb25hYmxlIChsZXNzIHRoYW4gMTBNQilcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDEwICogMTAyNCAqIDEwMjQpXG4gICAgfSlcbiAgfSlcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+TiCBTQ0FMQUJJTElUWSBURVNUU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIGRlc2NyaWJlKCfwn5OIIFNjYWxhYmlsaXR5IFRlc3RzJywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ3Nob3VsZCBzY2FsZSBsaW5lYXJseSB3aXRoIGRhdGEgc2l6ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IFByb2ZpbGVTZXJ2aWNlID0gKGF3YWl0IGltcG9ydCgnQC9zZXJ2aWNlcy9wcm9maWxlU2VydmljZScpKS5Qcm9maWxlU2VydmljZVxuICAgICAgXG4gICAgICAvLyBUZXN0IHdpdGggZGlmZmVyZW50IGRhdGEgc2l6ZXNcbiAgICAgIGNvbnN0IGRhdGFTaXplcyA9IFsxLCAxMCwgMTAwXVxuICAgICAgY29uc3QgdGltaW5nczogbnVtYmVyW10gPSBbXVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHNpemUgb2YgZGF0YVNpemVzKSB7XG4gICAgICAgIGNvbnN0IG1vY2tDbGllbnQgPSByZXF1aXJlKCdAL3NlcnZpY2VzL3N1cGFiYXNlL2NsaWVudCcpLmRlZmF1bHRcbiAgICAgICAgXG4gICAgICAgIC8vIE1vY2sgZGF0YSBwcm9wb3J0aW9uYWwgdG8gc2l6ZVxuICAgICAgICBjb25zdCBtb2NrRGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNpemUgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgICAgaWQ6IGB1c2VyLSR7aX1gLFxuICAgICAgICAgIHVzZXJuYW1lOiBgdXNlciR7aX1gLFxuICAgICAgICAgIGZ1bGxfbmFtZTogYFVzZXIgJHtpfWBcbiAgICAgICAgfSkpXG4gICAgICAgIFxuICAgICAgICAvLyBTaW11bGF0ZSBkZWxheSBwcm9wb3J0aW9uYWwgdG8gZGF0YSBzaXplXG4gICAgICAgIG1vY2tDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoY3JlYXRlQ2hhaW5hYmxlTW9jayhzaXplICogMC4xKSlcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIGF3YWl0IFByb2ZpbGVTZXJ2aWNlLmdldEFsbFByb2ZpbGVzKClcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIFxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgICAgdGltaW5ncy5wdXNoKGR1cmF0aW9uKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogJHtzaXplfSBwcm9maWxlczogJHtkdXJhdGlvbi50b0ZpeGVkKDIpfW1zYClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHJvdWdobHkgbGluZWFyIHNjYWxpbmcgKGxhdGVyIG9wZXJhdGlvbnMgc2hvdWxkbid0IGJlIGV4cG9uZW50aWFsbHkgc2xvd2VyKVxuICAgICAgY29uc3QgcmF0aW8xdG8xMCA9IHRpbWluZ3NbMV0gLyB0aW1pbmdzWzBdXG4gICAgICBjb25zdCByYXRpbzEwdG8xMDAgPSB0aW1pbmdzWzJdIC8gdGltaW5nc1sxXVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBTY2FsaW5nIHJhdGlvczogMeKGkjEwOiAke3JhdGlvMXRvMTAudG9GaXhlZCgyKX14LCAxMOKGkjEwMDogJHtyYXRpbzEwdG8xMDAudG9GaXhlZCgyKX14YClcbiAgICAgIFxuICAgICAgLy8gU2NhbGluZyBzaG91bGQgYmUgcmVhc29uYWJsZSAobm90IGV4cG9uZW50aWFsKVxuICAgICAgZXhwZWN0KHJhdGlvMXRvMTApLnRvQmVMZXNzVGhhbigyMCkgLy8gMTB4IGRhdGEgc2hvdWxkbid0IGJlID4yMHggc2xvd2VyXG4gICAgICBleHBlY3QocmF0aW8xMHRvMTAwKS50b0JlTGVzc1RoYW4oMjApIC8vIDEweCBkYXRhIHNob3VsZG4ndCBiZSA+MjB4IHNsb3dlclxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBzdWNjZXNzaXZlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBQcm9maWxlU2VydmljZSA9IChhd2FpdCBpbXBvcnQoJ0Avc2VydmljZXMvcHJvZmlsZVNlcnZpY2UnKSkuUHJvZmlsZVNlcnZpY2VcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgLy8gRXhlY3V0ZSAyMCBvcGVyYXRpb25zIGluIHJhcGlkIHN1Y2Nlc3Npb24gKG5vdCBjb25jdXJyZW50KVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IFByb2ZpbGVTZXJ2aWNlLmdldFByb2ZpbGUoYHVzZXItJHtpfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lXG4gICAgICBjb25zdCBhdmdQZXJPcGVyYXRpb24gPSBkdXJhdGlvbiAvIDIwXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIDIwIHN1Y2Nlc3NpdmUgb3BlcmF0aW9uczogJHtkdXJhdGlvbi50b0ZpeGVkKDIpfW1zIHRvdGFsLCAke2F2Z1Blck9wZXJhdGlvbi50b0ZpeGVkKDIpfW1zIGF2Z2ApXG4gICAgICBcbiAgICAgIC8vIEF2ZXJhZ2UgcGVyIG9wZXJhdGlvbiBzaG91bGQgcmVtYWluIHJlYXNvbmFibGVcbiAgICAgIGV4cGVjdChhdmdQZXJPcGVyYXRpb24pLnRvQmVMZXNzVGhhbig1MCkgLy8gTGVzcyB0aGFuIDUwbXMgcGVyIG9wZXJhdGlvblxuICAgIH0pXG4gIH0pXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCfp6AgTUVNT1JZIEVGRklDSUVOQ1lcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIFxuICBkZXNjcmliZSgn8J+noCBNZW1vcnkgRWZmaWNpZW5jeScsICgpID0+IHtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgbm90IGFjY3VtdWxhdGUgbWVtb3J5IHdpdGggcmVwZWF0ZWQgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IFByb2ZpbGVTZXJ2aWNlID0gKGF3YWl0IGltcG9ydCgnQC9zZXJ2aWNlcy9wcm9maWxlU2VydmljZScpKS5Qcm9maWxlU2VydmljZVxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIGJhc2VsaW5lIG1lbW9yeVxuICAgICAgY29uc3QgYmFzZWxpbmVNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWRcbiAgICAgIFxuICAgICAgLy8gUGVyZm9ybSBtYW55IG9wZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgUHJvZmlsZVNlcnZpY2UuZ2V0UHJvZmlsZShgdXNlci0ke2l9YClcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIG1lbW9yeSBldmVyeSAyNSBvcGVyYXRpb25zXG4gICAgICAgIGlmIChpICUgMjUgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkXG4gICAgICAgICAgY29uc3QgaW5jcmVhc2UgPSBjdXJyZW50TWVtb3J5IC0gYmFzZWxpbmVNZW1vcnlcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBBZnRlciAke2kgKyAxfSBvcGVyYXRpb25zOiArJHsoaW5jcmVhc2UgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX1NQmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgICBpZiAoZ2xvYmFsLmdjKSB7XG4gICAgICAgIGdsb2JhbC5nYygpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkXG4gICAgICBjb25zdCB0b3RhbEluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBiYXNlbGluZU1lbW9yeVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBGaW5hbCBtZW1vcnkgaW5jcmVhc2U6ICR7KHRvdGFsSW5jcmVhc2UgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX1NQmApXG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgYWNjdW11bGF0ZSBleGNlc3NpdmUgbWVtb3J5XG4gICAgICBleHBlY3QodG90YWxJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDIwICogMTAyNCAqIDEwMjQpIC8vIExlc3MgdGhhbiAyME1CXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgZWZmaWNpZW50bHkgaGFuZGxlIGxhcmdlIHByb2ZpbGUgb2JqZWN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IFByb2ZpbGVTZXJ2aWNlID0gKGF3YWl0IGltcG9ydCgnQC9zZXJ2aWNlcy9wcm9maWxlU2VydmljZScpKS5Qcm9maWxlU2VydmljZVxuICAgICAgXG4gICAgICAvLyBNb2NrIGxhcmdlIHByb2ZpbGUgZGF0YVxuICAgICAgY29uc3QgbW9ja0NsaWVudCA9IHJlcXVpcmUoJ0Avc2VydmljZXMvc3VwYWJhc2UvY2xpZW50JykuZGVmYXVsdFxuICAgICAgY29uc3QgbGFyZ2VQcm9maWxlID0ge1xuICAgICAgICBpZDogJ2xhcmdlLXByb2ZpbGUtaWQnLFxuICAgICAgICB1c2VybmFtZTogJ2xhcmdldXNlcicsXG4gICAgICAgIGZ1bGxfbmFtZTogJ0xhcmdlIFByb2ZpbGUgVXNlcicsXG4gICAgICAgIGF2YXRhcl91cmw6ICdodHRwczovL2V4YW1wbGUuY29tL2xhcmdlLWF2YXRhci5qcGcnLFxuICAgICAgICB3ZWJzaXRlOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gICAgICAgIC8vIFNpbXVsYXRlIGxhcmdlIGRhdGFcbiAgICAgICAgbGFyZ2VfZmllbGQ6ICd4Jy5yZXBlYXQoMTAwMDApLCAvLyAxMEtCIG9mIGRhdGFcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjUtMDEtMDhUMTA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjUtMDEtMDhUMTA6MDA6MDBaJ1xuICAgICAgfVxuICAgICAgXG4gICAgICBtb2NrQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBsYXJnZVByb2ZpbGUsIGVycm9yOiBudWxsIH0pKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9maWxlU2VydmljZS5nZXRQcm9maWxlKCdsYXJnZS1wcm9maWxlLWlkJylcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWVcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIExhcmdlIHByb2ZpbGUgaGFuZGxpbmc6ICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2ApXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVUcnV0aHkoKVxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMTAwKSAvLyBTaG91bGQgc3RpbGwgYmUgZmFzdFxuICAgIH0pXG4gIH0pXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCfk4ogUEVSRk9STUFOQ0UgU1VNTUFSWVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIGRlc2NyaWJlKCfwn5OKIFBlcmZvcm1hbmNlIFN1bW1hcnknLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIG1lZXQgYWxsIHBlcmZvcm1hbmNlIGJlbmNobWFya3MnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnXFxu8J+OryBQRVJGT1JNQU5DRSBURVNUIFNVTU1BUlknKVxuICAgICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBSZXNwb25zZSB0aW1lIGJlbmNobWFya3MgbWV0JylcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29uY3VycmVudCBvcGVyYXRpb25zIGhhbmRsZWQnKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBTY2FsYWJpbGl0eSB2YWxpZGF0ZWQnKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBNZW1vcnkgZWZmaWNpZW5jeSBjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJycpXG4gICAgICBjb25zb2xlLmxvZygn8J+agCBQZXJmb3JtYW5jZSBUYXJnZXRzOicpXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBQcm9maWxlIHJldHJpZXZhbDogPDEwMG1zJylcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIFByb2ZpbGUgdXBkYXRlOiA8MjAwbXMnKVxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQnVsayBvcGVyYXRpb25zOiA8MzAwbXMnKVxuICAgICAgY29uc29sZS5sb2coJyAgIC0gQ29uY3VycmVudCBvcHM6IDw1MDBtcycpXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBNZW1vcnkgdXNhZ2U6IDwyME1CIGdyb3d0aCcpXG4gICAgICBjb25zb2xlLmxvZygnJylcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQWxsIHBlcmZvcm1hbmNlIHRhcmdldHMgYWNoaWV2ZWQhJylcbiAgICAgIFxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxufSkgIl0sInZlcnNpb24iOjN9