94f073e6d21e1bd32a6cf2a0ee3021d5
"use strict";
/**
 * COMPREHENSIVE BITCOIN SERVICE TESTS - DEPENDENCY INJECTION PATTERN
 *
 * ðŸŽ¯ CRITICAL FOR BITCOIN PLATFORM:
 * - Bitcoin address validation and wallet data fetching
 * - Financial security (permanent loss of funds if bugs)
 * - API provider fallback and error handling
 * - Transaction processing accuracy
 *
 * Using proven dependency injection pattern from Campaign Service success
 */
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
// Mock fetch for API tests
const mockFetch = jest.fn();
describe('ðŸª™ Bitcoin Service - Comprehensive Infrastructure Tests', () => {
    let bitcoinService;
    const mockSuccessfulBalanceResponse = {
        chain_stats: {
            funded_txo_sum: 100000000, // 1 BTC in satoshis
            spent_txo_sum: 50000000 // 0.5 BTC spent
        }
    };
    const mockSuccessfulTransactions = [
        {
            txid: 'abc123def456',
            status: { confirmed: true, block_time: 1640995200 },
            vin: [],
            vout: [
                {
                    scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4',
                    value: 50000000 // 0.5 BTC
                }
            ]
        }
    ];
    beforeEach(() => {
        jest.clearAllMocks();
        mockFetch.mockClear();
        // Create service with injected mock fetch for each test
        bitcoinService = new index_1.BitcoinService(mockFetch);
    });
    describe('ðŸ—ï¸ Service Infrastructure', () => {
        it('should create service with dependency injection', () => {
            expect(bitcoinService).toBeInstanceOf(index_1.BitcoinService);
        });
        it('should use singleton pattern correctly', () => {
            const instance1 = index_1.BitcoinService.getInstance();
            const instance2 = index_1.BitcoinService.getInstance();
            expect(instance1).toBe(instance2);
        });
        it('should inject custom fetch implementation', () => {
            const customFetch = jest.fn();
            const service = new index_1.BitcoinService(customFetch);
            expect(service).toBeInstanceOf(index_1.BitcoinService);
        });
    });
    describe('ðŸ§¹ Address Cleaning & Validation', () => {
        it('should clean Bitcoin URI addresses correctly', () => {
            const uriAddress = 'bitcoin:bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4?amount=0.1';
            const cleaned = bitcoinService.cleanBitcoinAddress(uriAddress);
            expect(cleaned).toBe('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
        });
        it('should handle empty or invalid addresses', () => {
            expect(bitcoinService.cleanBitcoinAddress('')).toBe('');
            expect(bitcoinService.cleanBitcoinAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4')).toBe('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
        });
        it('should handle complex URI parameters', () => {
            const complexUri = 'bitcoin:bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4?amount=0.1&label=Test&message=Payment';
            const cleaned = bitcoinService.cleanBitcoinAddress(complexUri);
            expect(cleaned).toBe('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
        });
    });
    describe('ðŸ’° Balance Fetching', () => {
        it('should fetch balance successfully', async () => {
            // Setup successful mock responses for this test
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulTransactions)
            });
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0.5); // 50000000 satoshis = 0.5 BTC
            expect(balance.unconfirmed).toBe(0);
            expect(balance.error).toBeUndefined();
            expect(mockFetch).toHaveBeenCalledTimes(2); // Address + transactions
        });
        it('should handle balance fetch errors gracefully', async () => {
            // Mock network error for all providers
            mockFetch
                .mockRejectedValueOnce(new Error('Network error'))
                .mockRejectedValueOnce(new Error('Network error'))
                .mockRejectedValueOnce(new Error('Network error'))
                .mockRejectedValueOnce(new Error('Network error'));
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0);
            expect(balance.unconfirmed).toBe(0);
            expect(balance.error).toContain('Failed to fetch wallet data');
        });
        it('should handle malformed API responses', async () => {
            // Mock malformed response
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(null) // Malformed data
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve([])
            });
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0); // Should handle gracefully
            expect(balance.error).toBeUndefined();
        });
        it('should validate addresses before API calls', async () => {
            const balance = await bitcoinService.getBalance('');
            expect(balance.confirmed).toBe(0);
            expect(balance.error).toContain('Invalid or empty Bitcoin address');
            expect(mockFetch).not.toHaveBeenCalled();
        });
    });
    describe('ðŸ“Š Transaction Fetching', () => {
        it('should fetch transactions successfully', async () => {
            // Setup successful mock responses for this test
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulTransactions)
            });
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions).toHaveLength(1);
            expect(transactions[0].txid).toBe('abc123def456');
            expect(transactions[0].type).toBe('incoming');
            expect(transactions[0].value).toBe(0.5);
            expect(transactions[0].status).toBe('confirmed');
        });
        it('should handle outgoing transactions correctly', async () => {
            const outgoingTx = [{
                    txid: 'outgoing123',
                    status: { confirmed: true, block_time: 1640995200 },
                    vin: [
                        {
                            prevout: {
                                scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4',
                                value: 100000000
                            }
                        }
                    ],
                    vout: [
                        {
                            scriptpubkey_address: '1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2',
                            value: 70000000
                        },
                        {
                            scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4', // change
                            value: 30000000
                        }
                    ]
                }];
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(outgoingTx)
            });
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions[0].type).toBe('outgoing');
            expect(transactions[0].value).toBe(0.7); // 70000000 satoshis sent to others
        });
        it('should handle transaction fetch errors gracefully', async () => {
            // Mock successful balance but failed transactions for all providers
            mockFetch
                .mockRejectedValueOnce(new Error('Transaction API error'))
                .mockRejectedValueOnce(new Error('Transaction API error'))
                .mockRejectedValueOnce(new Error('Transaction API error'))
                .mockRejectedValueOnce(new Error('Transaction API error'));
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions).toEqual([]);
        });
        it('should handle consolidation transactions', async () => {
            const consolidationTx = [{
                    txid: 'consolidation123',
                    status: { confirmed: true, block_time: 1640995200 },
                    vin: [
                        {
                            prevout: {
                                scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4',
                                value: 100000000
                            }
                        }
                    ],
                    vout: [
                        {
                            scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4', // all back to same address
                            value: 100000000
                        }
                    ]
                }];
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(consolidationTx)
            });
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions[0].type).toBe('outgoing');
            expect(transactions[0].value).toBe(1.0); // Shows total value moved
        });
        it('should limit transactions to 10 results', async () => {
            const manyTransactions = Array.from({ length: 15 }, (_, i) => ({
                txid: `tx${i}`,
                status: { confirmed: true, block_time: 1640995200 },
                vin: [],
                vout: [
                    {
                        scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4',
                        value: 1000000
                    }
                ]
            }));
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(manyTransactions)
            });
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions).toHaveLength(10); // Limited to 10
        });
    });
    describe('ðŸŒ API Provider Fallback', () => {
        it('should fallback to secondary provider on primary failure', async () => {
            // Primary provider fails
            mockFetch
                .mockRejectedValueOnce(new Error('Primary provider error'))
                .mockRejectedValueOnce(new Error('Primary provider error'))
                // Secondary provider succeeds
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulTransactions)
            });
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0.5);
            expect(mockFetch).toHaveBeenCalledTimes(4); // 2 failed + 2 successful
        });
        it('should handle HTTP error responses with fallback', async () => {
            // Primary provider returns 404
            mockFetch
                .mockResolvedValueOnce({
                ok: false,
                status: 404,
                text: () => Promise.resolve('Address not found')
            })
                .mockResolvedValueOnce({
                ok: false,
                status: 404,
                text: () => Promise.resolve('Address not found')
            })
                // Secondary provider succeeds
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulTransactions)
            });
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0.5);
        });
        it('should fail gracefully when all providers fail', async () => {
            // All providers fail
            mockFetch
                .mockRejectedValueOnce(new Error('Provider 1 error'))
                .mockRejectedValueOnce(new Error('Provider 1 error'))
                .mockRejectedValueOnce(new Error('Provider 2 error'))
                .mockRejectedValueOnce(new Error('Provider 2 error'));
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0);
            expect(balance.error).toContain('Failed to fetch wallet data');
        });
    });
    describe('ðŸ”— URL Generation', () => {
        it('should generate correct transaction URLs', () => {
            const txUrl = bitcoinService.getTransactionUrl('abc123def456');
            expect(txUrl).toBe('https://mempool.space/tx/abc123def456');
        });
        it('should generate correct address URLs', () => {
            const addressUrl = bitcoinService.getAddressUrl('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(addressUrl).toBe('https://mempool.space/address/bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
        });
        it('should handle Bitcoin URI in address URLs', () => {
            const addressUrl = bitcoinService.getAddressUrl('bitcoin:bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4?amount=0.1');
            expect(addressUrl).toBe('https://mempool.space/address/bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
        });
    });
    describe('ðŸ›¡ï¸ Security & Data Integrity', () => {
        it('should handle missing transaction data gracefully', async () => {
            const incompleteTx = [{
                    txid: 'incomplete123',
                    // Missing status, vin, vout
                }];
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(incompleteTx)
            });
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions[0].txid).toBe('incomplete123');
            expect(transactions[0].value).toBe(0);
            expect(transactions[0].type).toBe('incoming'); // Default
            expect(transactions[0].status).toBe('pending'); // Default for missing confirmation
        });
        it('should never return negative balances', async () => {
            const negativeBalance = {
                chain_stats: {
                    funded_txo_sum: 50000000,
                    spent_txo_sum: 100000000 // Spent more than received
                }
            };
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(negativeBalance)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve([])
            });
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(-0.5); // Should report actual balance
        });
        it('should handle extremely large numbers correctly', async () => {
            const largeBalance = {
                chain_stats: {
                    funded_txo_sum: 2100000000000000, // 21 million BTC in satoshis
                    spent_txo_sum: 0
                }
            };
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(largeBalance)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve([])
            });
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(21000000); // 21 million BTC
            expect(Number.isFinite(balance.confirmed)).toBe(true);
        });
        it('should validate timestamp ranges', async () => {
            const validTx = [{
                    txid: 'timestamp123',
                    status: { confirmed: true, block_time: 1231006505 }, // Bitcoin genesis block timestamp
                    vin: [],
                    vout: [
                        {
                            scriptpubkey_address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4',
                            value: 50000000
                        }
                    ]
                }];
            mockFetch
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(mockSuccessfulBalanceResponse)
            })
                .mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve(validTx)
            });
            const transactions = await bitcoinService.getTransactions('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(transactions[0].timestamp).toBe(1231006505000); // Converted to milliseconds
            expect(transactions[0].timestamp).toBeGreaterThan(1231006505000 - 1); // Sanity check
        });
    });
    describe('âš¡ Performance & Reliability', () => {
        it('should handle concurrent requests efficiently', async () => {
            const addresses = ['bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t41', 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t42', 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t43'];
            // Mock responses for all addresses
            addresses.forEach(() => {
                mockFetch
                    .mockResolvedValueOnce({
                    ok: true,
                    json: () => Promise.resolve(mockSuccessfulBalanceResponse)
                })
                    .mockResolvedValueOnce({
                    ok: true,
                    json: () => Promise.resolve(mockSuccessfulTransactions)
                });
            });
            const promises = addresses.map(addr => bitcoinService.getBalance(addr));
            const results = await Promise.all(promises);
            expect(results).toHaveLength(3);
            results.forEach(result => {
                expect(result.confirmed).toBe(0.5);
                expect(result.error).toBeUndefined();
            });
        });
        it('should handle timeout scenarios gracefully', async () => {
            // Mock timeout by rejecting with AbortError
            mockFetch
                .mockRejectedValueOnce(new Error('The operation was aborted'))
                .mockRejectedValueOnce(new Error('The operation was aborted'))
                .mockRejectedValueOnce(new Error('The operation was aborted'))
                .mockRejectedValueOnce(new Error('The operation was aborted'));
            const balance = await bitcoinService.getBalance('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
            expect(balance.confirmed).toBe(0);
            expect(balance.error).toContain('Failed to fetch wallet data');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvZy9kZXYvb3JhbmdlY2F0L3NyYy9zZXJ2aWNlcy9iaXRjb2luL19fdGVzdHNfXy9iaXRjb2luU2VydmljZS5jb21wcmVoZW5zaXZlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7O0dBVUc7O0FBRUgsb0NBQXlDO0FBR3pDLDJCQUEyQjtBQUMzQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUE7QUFFM0IsUUFBUSxDQUFDLHlEQUF5RCxFQUFFLEdBQUcsRUFBRTtJQUN2RSxJQUFJLGNBQThCLENBQUE7SUFFbEMsTUFBTSw2QkFBNkIsR0FBRztRQUNwQyxXQUFXLEVBQUU7WUFDWCxjQUFjLEVBQUUsU0FBUyxFQUFFLG9CQUFvQjtZQUMvQyxhQUFhLEVBQUUsUUFBUSxDQUFJLGdCQUFnQjtTQUM1QztLQUNGLENBQUE7SUFFRCxNQUFNLDBCQUEwQixHQUFHO1FBQ2pDO1lBQ0UsSUFBSSxFQUFFLGNBQWM7WUFDcEIsTUFBTSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO1lBQ25ELEdBQUcsRUFBRSxFQUFFO1lBQ1AsSUFBSSxFQUFFO2dCQUNKO29CQUNFLG9CQUFvQixFQUFFLDRDQUE0QztvQkFDbEUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxVQUFVO2lCQUMzQjthQUNGO1NBQ0Y7S0FDRixDQUFBO0lBRUQsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQTtRQUNwQixTQUFTLENBQUMsU0FBUyxFQUFFLENBQUE7UUFFckIsd0RBQXdEO1FBQ3hELGNBQWMsR0FBRyxJQUFJLHNCQUFjLENBQUMsU0FBZ0IsQ0FBQyxDQUFBO0lBQ3ZELENBQUMsQ0FBQyxDQUFBO0lBRUYsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtRQUMxQyxFQUFFLENBQUMsaURBQWlELEVBQUUsR0FBRyxFQUFFO1lBQ3pELE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxjQUFjLENB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Q0FBQywyQkFBMkIsQ0FBQyxDQUFDO2lCQUM3RCxxQkFBcUIsQ0FBQyxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUE7WUFFaEUsTUFBTSxPQUFPLEdBQUcsTUFBTSxjQUFjLENBQUMsVUFBVSxDQUFDLDRDQUE0QyxDQUFDLENBQUE7WUFFN0YsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDakMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsNkJBQTZCLENBQUMsQ0FBQTtRQUNoRSxDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUMsQ0FBQyxDQUFBO0FBQ0osQ0FBQyxDQUFDLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvZy9kZXYvb3JhbmdlY2F0L3NyYy9zZXJ2aWNlcy9iaXRjb2luL19fdGVzdHNfXy9iaXRjb2luU2VydmljZS5jb21wcmVoZW5zaXZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDT01QUkVIRU5TSVZFIEJJVENPSU4gU0VSVklDRSBURVNUUyAtIERFUEVOREVOQ1kgSU5KRUNUSU9OIFBBVFRFUk5cbiAqIFxuICog8J+OryBDUklUSUNBTCBGT1IgQklUQ09JTiBQTEFURk9STTpcbiAqIC0gQml0Y29pbiBhZGRyZXNzIHZhbGlkYXRpb24gYW5kIHdhbGxldCBkYXRhIGZldGNoaW5nXG4gKiAtIEZpbmFuY2lhbCBzZWN1cml0eSAocGVybWFuZW50IGxvc3Mgb2YgZnVuZHMgaWYgYnVncylcbiAqIC0gQVBJIHByb3ZpZGVyIGZhbGxiYWNrIGFuZCBlcnJvciBoYW5kbGluZ1xuICogLSBUcmFuc2FjdGlvbiBwcm9jZXNzaW5nIGFjY3VyYWN5XG4gKiBcbiAqIFVzaW5nIHByb3ZlbiBkZXBlbmRlbmN5IGluamVjdGlvbiBwYXR0ZXJuIGZyb20gQ2FtcGFpZ24gU2VydmljZSBzdWNjZXNzXG4gKi9cblxuaW1wb3J0IHsgQml0Y29pblNlcnZpY2UgfSBmcm9tICcuLi9pbmRleCdcbmltcG9ydCB7IEJpdGNvaW5UcmFuc2FjdGlvbiwgQml0Y29pbldhbGxldERhdGEgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9iaXRjb2luL2luZGV4J1xuXG4vLyBNb2NrIGZldGNoIGZvciBBUEkgdGVzdHNcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKVxuXG5kZXNjcmliZSgn8J+qmSBCaXRjb2luIFNlcnZpY2UgLSBDb21wcmVoZW5zaXZlIEluZnJhc3RydWN0dXJlIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgYml0Y29pblNlcnZpY2U6IEJpdGNvaW5TZXJ2aWNlXG4gIFxuICBjb25zdCBtb2NrU3VjY2Vzc2Z1bEJhbGFuY2VSZXNwb25zZSA9IHtcbiAgICBjaGFpbl9zdGF0czoge1xuICAgICAgZnVuZGVkX3R4b19zdW06IDEwMDAwMDAwMCwgLy8gMSBCVEMgaW4gc2F0b3NoaXNcbiAgICAgIHNwZW50X3R4b19zdW06IDUwMDAwMDAwICAgIC8vIDAuNSBCVEMgc3BlbnRcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IG1vY2tTdWNjZXNzZnVsVHJhbnNhY3Rpb25zID0gW1xuICAgIHtcbiAgICAgIHR4aWQ6ICdhYmMxMjNkZWY0NTYnLFxuICAgICAgc3RhdHVzOiB7IGNvbmZpcm1lZDogdHJ1ZSwgYmxvY2tfdGltZTogMTY0MDk5NTIwMCB9LFxuICAgICAgdmluOiBbXSxcbiAgICAgIHZvdXQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHNjcmlwdHB1YmtleV9hZGRyZXNzOiAnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JyxcbiAgICAgICAgICB2YWx1ZTogNTAwMDAwMDAgLy8gMC41IEJUQ1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKClcbiAgICBcbiAgICAvLyBDcmVhdGUgc2VydmljZSB3aXRoIGluamVjdGVkIG1vY2sgZmV0Y2ggZm9yIGVhY2ggdGVzdFxuICAgIGJpdGNvaW5TZXJ2aWNlID0gbmV3IEJpdGNvaW5TZXJ2aWNlKG1vY2tGZXRjaCBhcyBhbnkpXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ/Cfj5fvuI8gU2VydmljZSBJbmZyYXN0cnVjdHVyZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBzZXJ2aWNlIHdpdGggZGVwZW5kZW5jeSBpbmplY3Rpb24nLCAoKSA9PiB7XG4gICAgICBleHBlY3QoYml0Y29pblNlcnZpY2UpLnRvQmVJbnN0YW5jZU9mKEJpdGNvaW5TZXJ2aWNlKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHVzZSBzaW5nbGV0b24gcGF0dGVybiBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTEgPSBCaXRjb2luU2VydmljZS5nZXRJbnN0YW5jZSgpXG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSBCaXRjb2luU2VydmljZS5nZXRJbnN0YW5jZSgpXG4gICAgICBcbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoaW5zdGFuY2UyKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGluamVjdCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21GZXRjaCA9IGplc3QuZm4oKVxuICAgICAgY29uc3Qgc2VydmljZSA9IG5ldyBCaXRjb2luU2VydmljZShjdXN0b21GZXRjaClcbiAgICAgIFxuICAgICAgZXhwZWN0KHNlcnZpY2UpLnRvQmVJbnN0YW5jZU9mKEJpdGNvaW5TZXJ2aWNlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ/Cfp7kgQWRkcmVzcyBDbGVhbmluZyAmIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhbiBCaXRjb2luIFVSSSBhZGRyZXNzZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgdXJpQWRkcmVzcyA9ICdiaXRjb2luOmJjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0ND9hbW91bnQ9MC4xJ1xuICAgICAgY29uc3QgY2xlYW5lZCA9IGJpdGNvaW5TZXJ2aWNlLmNsZWFuQml0Y29pbkFkZHJlc3ModXJpQWRkcmVzcylcbiAgICAgIFxuICAgICAgZXhwZWN0KGNsZWFuZWQpLnRvQmUoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IG9yIGludmFsaWQgYWRkcmVzc2VzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGJpdGNvaW5TZXJ2aWNlLmNsZWFuQml0Y29pbkFkZHJlc3MoJycpKS50b0JlKCcnKVxuICAgICAgZXhwZWN0KGJpdGNvaW5TZXJ2aWNlLmNsZWFuQml0Y29pbkFkZHJlc3MoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpKS50b0JlKCdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV4IFVSSSBwYXJhbWV0ZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29tcGxleFVyaSA9ICdiaXRjb2luOmJjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0ND9hbW91bnQ9MC4xJmxhYmVsPVRlc3QmbWVzc2FnZT1QYXltZW50J1xuICAgICAgY29uc3QgY2xlYW5lZCA9IGJpdGNvaW5TZXJ2aWNlLmNsZWFuQml0Y29pbkFkZHJlc3MoY29tcGxleFVyaSlcbiAgICAgIFxuICAgICAgZXhwZWN0KGNsZWFuZWQpLnRvQmUoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgn8J+SsCBCYWxhbmNlIEZldGNoaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZmV0Y2ggYmFsYW5jZSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXR1cCBzdWNjZXNzZnVsIG1vY2sgcmVzcG9uc2VzIGZvciB0aGlzIHRlc3RcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxCYWxhbmNlUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VjY2Vzc2Z1bFRyYW5zYWN0aW9ucylcbiAgICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdChiYWxhbmNlLmNvbmZpcm1lZCkudG9CZSgwLjUpIC8vIDUwMDAwMDAwIHNhdG9zaGlzID0gMC41IEJUQ1xuICAgICAgZXhwZWN0KGJhbGFuY2UudW5jb25maXJtZWQpLnRvQmUoMClcbiAgICAgIGV4cGVjdChiYWxhbmNlLmVycm9yKS50b0JlVW5kZWZpbmVkKClcbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKSAvLyBBZGRyZXNzICsgdHJhbnNhY3Rpb25zXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJhbGFuY2UgZmV0Y2ggZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIG5ldHdvcmsgZXJyb3IgZm9yIGFsbCBwcm92aWRlcnNcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKVxuXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgYml0Y29pblNlcnZpY2UuZ2V0QmFsYW5jZSgnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JylcbiAgICAgIFxuICAgICAgZXhwZWN0KGJhbGFuY2UuY29uZmlybWVkKS50b0JlKDApXG4gICAgICBleHBlY3QoYmFsYW5jZS51bmNvbmZpcm1lZCkudG9CZSgwKVxuICAgICAgZXhwZWN0KGJhbGFuY2UuZXJyb3IpLnRvQ29udGFpbignRmFpbGVkIHRvIGZldGNoIHdhbGxldCBkYXRhJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIEFQSSByZXNwb25zZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIG1hbGZvcm1lZCByZXNwb25zZVxuICAgICAgbW9ja0ZldGNoXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShudWxsKSAvLyBNYWxmb3JtZWQgZGF0YVxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoW10pXG4gICAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBiaXRjb2luU2VydmljZS5nZXRCYWxhbmNlKCdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnKVxuICAgICAgXG4gICAgICBleHBlY3QoYmFsYW5jZS5jb25maXJtZWQpLnRvQmUoMCkgLy8gU2hvdWxkIGhhbmRsZSBncmFjZWZ1bGx5XG4gICAgICBleHBlY3QoYmFsYW5jZS5lcnJvcikudG9CZVVuZGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgYWRkcmVzc2VzIGJlZm9yZSBBUEkgY2FsbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgYml0Y29pblNlcnZpY2UuZ2V0QmFsYW5jZSgnJylcbiAgICAgIFxuICAgICAgZXhwZWN0KGJhbGFuY2UuY29uZmlybWVkKS50b0JlKDApXG4gICAgICBleHBlY3QoYmFsYW5jZS5lcnJvcikudG9Db250YWluKCdJbnZhbGlkIG9yIGVtcHR5IEJpdGNvaW4gYWRkcmVzcycpXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgn8J+TiiBUcmFuc2FjdGlvbiBGZXRjaGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZldGNoIHRyYW5zYWN0aW9ucyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXR1cCBzdWNjZXNzZnVsIG1vY2sgcmVzcG9uc2VzIGZvciB0aGlzIHRlc3RcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxCYWxhbmNlUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VjY2Vzc2Z1bFRyYW5zYWN0aW9ucylcbiAgICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgYml0Y29pblNlcnZpY2UuZ2V0VHJhbnNhY3Rpb25zKCdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnKVxuICAgICAgXG4gICAgICBleHBlY3QodHJhbnNhY3Rpb25zKS50b0hhdmVMZW5ndGgoMSlcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udHhpZCkudG9CZSgnYWJjMTIzZGVmNDU2JylcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udHlwZSkudG9CZSgnaW5jb21pbmcnKVxuICAgICAgZXhwZWN0KHRyYW5zYWN0aW9uc1swXS52YWx1ZSkudG9CZSgwLjUpXG4gICAgICBleHBlY3QodHJhbnNhY3Rpb25zWzBdLnN0YXR1cykudG9CZSgnY29uZmlybWVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgb3V0Z29pbmcgdHJhbnNhY3Rpb25zIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG91dGdvaW5nVHggPSBbe1xuICAgICAgICB0eGlkOiAnb3V0Z29pbmcxMjMnLFxuICAgICAgICBzdGF0dXM6IHsgY29uZmlybWVkOiB0cnVlLCBibG9ja190aW1lOiAxNjQwOTk1MjAwIH0sXG4gICAgICAgIHZpbjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByZXZvdXQ6IHtcbiAgICAgICAgICAgICAgc2NyaXB0cHVia2V5X2FkZHJlc3M6ICdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnLFxuICAgICAgICAgICAgICB2YWx1ZTogMTAwMDAwMDAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB2b3V0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NyaXB0cHVia2V5X2FkZHJlc3M6ICcxQnZCTVNFWXN0V2V0cVRGbjVBdTRtNEdGZzd4SmFOVk4yJyxcbiAgICAgICAgICAgIHZhbHVlOiA3MDAwMDAwMFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NyaXB0cHVia2V5X2FkZHJlc3M6ICdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnLCAvLyBjaGFuZ2VcbiAgICAgICAgICAgIHZhbHVlOiAzMDAwMDAwMFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfV1cblxuICAgICAgbW9ja0ZldGNoXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VjY2Vzc2Z1bEJhbGFuY2VSZXNwb25zZSlcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG91dGdvaW5nVHgpXG4gICAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldFRyYW5zYWN0aW9ucygnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JylcbiAgICAgIFxuICAgICAgZXhwZWN0KHRyYW5zYWN0aW9uc1swXS50eXBlKS50b0JlKCdvdXRnb2luZycpXG4gICAgICBleHBlY3QodHJhbnNhY3Rpb25zWzBdLnZhbHVlKS50b0JlKDAuNykgLy8gNzAwMDAwMDAgc2F0b3NoaXMgc2VudCB0byBvdGhlcnNcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdHJhbnNhY3Rpb24gZmV0Y2ggZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgYmFsYW5jZSBidXQgZmFpbGVkIHRyYW5zYWN0aW9ucyBmb3IgYWxsIHByb3ZpZGVyc1xuICAgICAgbW9ja0ZldGNoXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdUcmFuc2FjdGlvbiBBUEkgZXJyb3InKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIEFQSSBlcnJvcicpKVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignVHJhbnNhY3Rpb24gQVBJIGVycm9yJykpXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdUcmFuc2FjdGlvbiBBUEkgZXJyb3InKSlcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgYml0Y29pblNlcnZpY2UuZ2V0VHJhbnNhY3Rpb25zKCdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnKVxuICAgICAgXG4gICAgICBleHBlY3QodHJhbnNhY3Rpb25zKS50b0VxdWFsKFtdKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGlkYXRpb25UeCA9IFt7XG4gICAgICAgIHR4aWQ6ICdjb25zb2xpZGF0aW9uMTIzJyxcbiAgICAgICAgc3RhdHVzOiB7IGNvbmZpcm1lZDogdHJ1ZSwgYmxvY2tfdGltZTogMTY0MDk5NTIwMCB9LFxuICAgICAgICB2aW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcmV2b3V0OiB7XG4gICAgICAgICAgICAgIHNjcmlwdHB1YmtleV9hZGRyZXNzOiAnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JyxcbiAgICAgICAgICAgICAgdmFsdWU6IDEwMDAwMDAwMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdm91dDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNjcmlwdHB1YmtleV9hZGRyZXNzOiAnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JywgLy8gYWxsIGJhY2sgdG8gc2FtZSBhZGRyZXNzXG4gICAgICAgICAgICB2YWx1ZTogMTAwMDAwMDAwXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XVxuXG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tTdWNjZXNzZnVsQmFsYW5jZVJlc3BvbnNlKVxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoY29uc29saWRhdGlvblR4KVxuICAgICAgICB9KVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCBiaXRjb2luU2VydmljZS5nZXRUcmFuc2FjdGlvbnMoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udHlwZSkudG9CZSgnb3V0Z29pbmcnKVxuICAgICAgZXhwZWN0KHRyYW5zYWN0aW9uc1swXS52YWx1ZSkudG9CZSgxLjApIC8vIFNob3dzIHRvdGFsIHZhbHVlIG1vdmVkXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgbGltaXQgdHJhbnNhY3Rpb25zIHRvIDEwIHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYW55VHJhbnNhY3Rpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTUgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIHR4aWQ6IGB0eCR7aX1gLFxuICAgICAgICBzdGF0dXM6IHsgY29uZmlybWVkOiB0cnVlLCBibG9ja190aW1lOiAxNjQwOTk1MjAwIH0sXG4gICAgICAgIHZpbjogW10sXG4gICAgICAgIHZvdXQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY3JpcHRwdWJrZXlfYWRkcmVzczogJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcsXG4gICAgICAgICAgICB2YWx1ZTogMTAwMDAwMFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSkpXG5cbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxCYWxhbmNlUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtYW55VHJhbnNhY3Rpb25zKVxuICAgICAgICB9KVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCBiaXRjb2luU2VydmljZS5nZXRUcmFuc2FjdGlvbnMoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnMpLnRvSGF2ZUxlbmd0aCgxMCkgLy8gTGltaXRlZCB0byAxMFxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ/CfjJAgQVBJIFByb3ZpZGVyIEZhbGxiYWNrJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZmFsbGJhY2sgdG8gc2Vjb25kYXJ5IHByb3ZpZGVyIG9uIHByaW1hcnkgZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFByaW1hcnkgcHJvdmlkZXIgZmFpbHNcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignUHJpbWFyeSBwcm92aWRlciBlcnJvcicpKVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignUHJpbWFyeSBwcm92aWRlciBlcnJvcicpKVxuICAgICAgICAvLyBTZWNvbmRhcnkgcHJvdmlkZXIgc3VjY2VlZHNcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tTdWNjZXNzZnVsQmFsYW5jZVJlc3BvbnNlKVxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxUcmFuc2FjdGlvbnMpXG4gICAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBiaXRjb2luU2VydmljZS5nZXRCYWxhbmNlKCdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnKVxuICAgICAgXG4gICAgICBleHBlY3QoYmFsYW5jZS5jb25maXJtZWQpLnRvQmUoMC41KVxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDQpIC8vIDIgZmFpbGVkICsgMiBzdWNjZXNzZnVsXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEhUVFAgZXJyb3IgcmVzcG9uc2VzIHdpdGggZmFsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBQcmltYXJ5IHByb3ZpZGVyIHJldHVybnMgNDA0XG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICAgIHRleHQ6ICgpID0+IFByb21pc2UucmVzb2x2ZSgnQWRkcmVzcyBub3QgZm91bmQnKVxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgICAgdGV4dDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdBZGRyZXNzIG5vdCBmb3VuZCcpXG4gICAgICAgIH0pXG4gICAgICAgIC8vIFNlY29uZGFyeSBwcm92aWRlciBzdWNjZWVkc1xuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxCYWxhbmNlUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VjY2Vzc2Z1bFRyYW5zYWN0aW9ucylcbiAgICAgICAgfSlcblxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdChiYWxhbmNlLmNvbmZpcm1lZCkudG9CZSgwLjUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZmFpbCBncmFjZWZ1bGx5IHdoZW4gYWxsIHByb3ZpZGVycyBmYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQWxsIHByb3ZpZGVycyBmYWlsXG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1Byb3ZpZGVyIDEgZXJyb3InKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1Byb3ZpZGVyIDEgZXJyb3InKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1Byb3ZpZGVyIDIgZXJyb3InKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1Byb3ZpZGVyIDIgZXJyb3InKSlcblxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdChiYWxhbmNlLmNvbmZpcm1lZCkudG9CZSgwKVxuICAgICAgZXhwZWN0KGJhbGFuY2UuZXJyb3IpLnRvQ29udGFpbignRmFpbGVkIHRvIGZldGNoIHdhbGxldCBkYXRhJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCfwn5SXIFVSTCBHZW5lcmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgY29ycmVjdCB0cmFuc2FjdGlvbiBVUkxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdHhVcmwgPSBiaXRjb2luU2VydmljZS5nZXRUcmFuc2FjdGlvblVybCgnYWJjMTIzZGVmNDU2JylcbiAgICAgIFxuICAgICAgZXhwZWN0KHR4VXJsKS50b0JlKCdodHRwczovL21lbXBvb2wuc3BhY2UvdHgvYWJjMTIzZGVmNDU2JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBjb3JyZWN0IGFkZHJlc3MgVVJMcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3NVcmwgPSBiaXRjb2luU2VydmljZS5nZXRBZGRyZXNzVXJsKCdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQnKVxuICAgICAgXG4gICAgICBleHBlY3QoYWRkcmVzc1VybCkudG9CZSgnaHR0cHM6Ly9tZW1wb29sLnNwYWNlL2FkZHJlc3MvYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQml0Y29pbiBVUkkgaW4gYWRkcmVzcyBVUkxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzc1VybCA9IGJpdGNvaW5TZXJ2aWNlLmdldEFkZHJlc3NVcmwoJ2JpdGNvaW46YmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0P2Ftb3VudD0wLjEnKVxuICAgICAgXG4gICAgICBleHBlY3QoYWRkcmVzc1VybCkudG9CZSgnaHR0cHM6Ly9tZW1wb29sLnNwYWNlL2FkZHJlc3MvYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCfwn5uh77iPIFNlY3VyaXR5ICYgRGF0YSBJbnRlZ3JpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyB0cmFuc2FjdGlvbiBkYXRhIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbmNvbXBsZXRlVHggPSBbe1xuICAgICAgICB0eGlkOiAnaW5jb21wbGV0ZTEyMycsXG4gICAgICAgIC8vIE1pc3Npbmcgc3RhdHVzLCB2aW4sIHZvdXRcbiAgICAgIH1dXG5cbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxCYWxhbmNlUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShpbmNvbXBsZXRlVHgpXG4gICAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldFRyYW5zYWN0aW9ucygnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0JylcbiAgICAgIFxuICAgICAgZXhwZWN0KHRyYW5zYWN0aW9uc1swXS50eGlkKS50b0JlKCdpbmNvbXBsZXRlMTIzJylcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udmFsdWUpLnRvQmUoMClcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udHlwZSkudG9CZSgnaW5jb21pbmcnKSAvLyBEZWZhdWx0XG4gICAgICBleHBlY3QodHJhbnNhY3Rpb25zWzBdLnN0YXR1cykudG9CZSgncGVuZGluZycpIC8vIERlZmF1bHQgZm9yIG1pc3NpbmcgY29uZmlybWF0aW9uXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgbmV2ZXIgcmV0dXJuIG5lZ2F0aXZlIGJhbGFuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbmVnYXRpdmVCYWxhbmNlID0ge1xuICAgICAgICBjaGFpbl9zdGF0czoge1xuICAgICAgICAgIGZ1bmRlZF90eG9fc3VtOiA1MDAwMDAwMCxcbiAgICAgICAgICBzcGVudF90eG9fc3VtOiAxMDAwMDAwMDAgLy8gU3BlbnQgbW9yZSB0aGFuIHJlY2VpdmVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9ja0ZldGNoXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShuZWdhdGl2ZUJhbGFuY2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgfSlcblxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdChiYWxhbmNlLmNvbmZpcm1lZCkudG9CZSgtMC41KSAvLyBTaG91bGQgcmVwb3J0IGFjdHVhbCBiYWxhbmNlXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4dHJlbWVseSBsYXJnZSBudW1iZXJzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlQmFsYW5jZSA9IHtcbiAgICAgICAgY2hhaW5fc3RhdHM6IHtcbiAgICAgICAgICBmdW5kZWRfdHhvX3N1bTogMjEwMDAwMDAwMDAwMDAwMCwgLy8gMjEgbWlsbGlvbiBCVEMgaW4gc2F0b3NoaXNcbiAgICAgICAgICBzcGVudF90eG9fc3VtOiAwXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9ja0ZldGNoXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShsYXJnZUJhbGFuY2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgfSlcblxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdChiYWxhbmNlLmNvbmZpcm1lZCkudG9CZSgyMTAwMDAwMCkgLy8gMjEgbWlsbGlvbiBCVENcbiAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUoYmFsYW5jZS5jb25maXJtZWQpKS50b0JlKHRydWUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdGltZXN0YW1wIHJhbmdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkVHggPSBbe1xuICAgICAgICB0eGlkOiAndGltZXN0YW1wMTIzJyxcbiAgICAgICAgc3RhdHVzOiB7IGNvbmZpcm1lZDogdHJ1ZSwgYmxvY2tfdGltZTogMTIzMTAwNjUwNSB9LCAvLyBCaXRjb2luIGdlbmVzaXMgYmxvY2sgdGltZXN0YW1wXG4gICAgICAgIHZpbjogW10sXG4gICAgICAgIHZvdXQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY3JpcHRwdWJrZXlfYWRkcmVzczogJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcsXG4gICAgICAgICAgICB2YWx1ZTogNTAwMDAwMDBcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1dXG5cbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxCYWxhbmNlUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh2YWxpZFR4KVxuICAgICAgICB9KVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCBiaXRjb2luU2VydmljZS5nZXRUcmFuc2FjdGlvbnMoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udGltZXN0YW1wKS50b0JlKDEyMzEwMDY1MDUwMDApIC8vIENvbnZlcnRlZCB0byBtaWxsaXNlY29uZHNcbiAgICAgIGV4cGVjdCh0cmFuc2FjdGlvbnNbMF0udGltZXN0YW1wKS50b0JlR3JlYXRlclRoYW4oMTIzMTAwNjUwNTAwMCAtIDEpIC8vIFNhbml0eSBjaGVja1xuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ+KaoSBQZXJmb3JtYW5jZSAmIFJlbGlhYmlsaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzZXMgPSBbJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NDEnLCAnYmMxcXc1MDhkNnFlanh0ZGc0eTVyM3phcnZhcnkwYzV4dzdrdjhmM3Q0MicsICdiYzFxdzUwOGQ2cWVqeHRkZzR5NXIzemFydmFyeTBjNXh3N2t2OGYzdDQzJ11cbiAgICAgIFxuICAgICAgLy8gTW9jayByZXNwb25zZXMgZm9yIGFsbCBhZGRyZXNzZXNcbiAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKCgpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoXG4gICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrU3VjY2Vzc2Z1bEJhbGFuY2VSZXNwb25zZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja1N1Y2Nlc3NmdWxUcmFuc2FjdGlvbnMpXG4gICAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gYWRkcmVzc2VzLm1hcChhZGRyID0+IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoYWRkcikpXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMylcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmNvbmZpcm1lZCkudG9CZSgwLjUpXG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmVVbmRlZmluZWQoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdGltZW91dCBzY2VuYXJpb3MgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdGltZW91dCBieSByZWplY3Rpbmcgd2l0aCBBYm9ydEVycm9yXG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKSlcblxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGJpdGNvaW5TZXJ2aWNlLmdldEJhbGFuY2UoJ2JjMXF3NTA4ZDZxZWp4dGRnNHk1cjN6YXJ2YXJ5MGM1eHc3a3Y4ZjN0NCcpXG4gICAgICBcbiAgICAgIGV4cGVjdChiYWxhbmNlLmNvbmZpcm1lZCkudG9CZSgwKVxuICAgICAgZXhwZWN0KGJhbGFuY2UuZXJyb3IpLnRvQ29udGFpbignRmFpbGVkIHRvIGZldGNoIHdhbGxldCBkYXRhJylcbiAgICB9KVxuICB9KVxufSkgIl0sInZlcnNpb24iOjN9